{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"api/","text":"Minute 1 We are assuming you have installed routerling via pip install routerling . If no, then go ahead and install it, otherwise let's dive in. 30,000 Foot View... from routerling import Router router = Router() router.GET('/v1/customers', lambda r, w, c: pass)","title":"Minute 1"},{"location":"api/#minute-1","text":"We are assuming you have installed routerling via pip install routerling . If no, then go ahead and install it, otherwise let's dive in.","title":"Minute 1"},{"location":"api/#30000-foot-view","text":"from routerling import Router router = Router() router.GET('/v1/customers', lambda r, w, c: pass)","title":"30,000 Foot View..."},{"location":"default/","text":"Routerling Super small micro framework for building enterprise microservices and or web applications. Why Another Python Web Framework? Because we needed something small enough to be learnt completely by new engineers in less than 5 minutes. Complete mastery with no gray spots .","title":"Home"},{"location":"default/#routerling","text":"Super small micro framework for building enterprise microservices and or web applications.","title":"Routerling"},{"location":"default/#why-another-python-web-framework","text":"Because we needed something small enough to be learnt completely by new engineers in less than 5 minutes. Complete mastery with no gray spots .","title":"Why Another Python Web Framework?"},{"location":"quickstart/","text":"Minute 1 We are assuming you have installed routerling via pip install routerling . If no, then go ahead and install it; If you have, then the clock is ticking so let's dive in. 1. Create a handler function import json from http import HTTPStatus from routerling import HttpRequest, ResponseWriter, Context async def get_one_customer(r: HttpRequest, w: ResponseWriter, c: Context): id = r.params.get('id') w.status = HTTPStatus.CREATED w.body = json.dumps({\"message\": f\"routerling is easy for customer {id}\"}) As you can see above - your handler function can be async if you desire and must accept 3 arguments that will be injected by routerling. We'll get back to them in Minute 3 2. Connect your handler to the routerling application from routerling import Router # create the application router = Router() # connect it to a route router.GET('/v1/customers/:id', get_one_customer) All HTTP methods i.e. GET , POST etc. are all supported Minute 2 That was quick wasn't it? even less than a minute? Well now we have an application, but it is no fun if we can't execute/run/interact with it. 3. Run your routerling application # development uvicorn application:router --reload # production gunicorn -w 4 -k uvicorn.workers.UvicornWorker application:router Replace the number after -w with the number of processors you desire to run your app with. !!! info \"Slow Down Tiger\" You might be asking - what about the applications port number etc? \ud83d\ude01 Minute 3 & 4 A promise is a promise. So it's time to tell you about routerling's objects. Don't fret - there are only 4 of them. 1. HttpRequest All handlers will receive this as their first argument i.e. ...(r: HttpRequest, ..., ...) and all HttpRequest objects come with the following bag of goodies. r.app: Router -> An instance of the base routerling application r.body: dict -> The body sent along with the request r.cookies: dict -> All the cookies sent with request [keys in lowercase] r.headers: dict -> All the headers sent with request [keys in lowercase] r.method: str -> GET , POST , DELETE ? What method type is the http request r.params: dict -> Querystring parameters and url masks /customers/:param1 parsed into a dictionary r.querystring: str -> The part after the ? i.e. example.com ?age=34 parsed in comma separated string form r.subdomain: str -> If request was made to a subdomain i.e. www.example.org or api.example.org then this holds the subdomain value e.g. www and api . r.url: str -> The url that matched to this handler as sent by the client 2. ResponseWriter All handlers receive this as the second argument i.e. ...(..., w: ResponseWriter, ...) as ResponseWriters help with responding to HttpRequests. w.abort(payload: any) -> If this is calledx then all PRE and POST hooks will be aborted w.body: any -> This will be sent back as the body of the response w.headers: tuple[2] | list[2] -> How headers are set i.e. w.headers = 'Set-Cookie', 'Token=12345; Max-Age=8700; Secure; HttpOnly' w.status: int -> HTTP status code to be sent back with the response 3. Context All handlers receive this as the third argument i.e. ...(..., ..., c: Context) to help with preserving state across a request lifecycle i.e. from start/reciept to finish/response. c.keep(alias: str, value: any) -> Save something that can be retrieved via Python descriptor semantics. i.e. c.alias will return the kept value. 4. Router This is the last internal routerling object to grok. You can instantiate it with an optional configuration that is stored as the application's global state. router = Router({'secret_key': '...'}) # or router = Router(function() -> dict) router.AFTER(url: str, handler: func, subdomain: str) -> Register a handler to run after all matches to the provided url i.e. router.AFTER('/v1/*', log_visit_in_db) router.BEFORE(url: str, handler: func, subdomain: str) -> Get a config value from the global store/state register router.CONFIG(url: str, handler: func, subdomain: str) -> Get a config value from the final readonly app config set at router instantiation. router.GET(url: str, handler: func, subdomain: str) -> Registers your custom handlers/functions to be invoked when a url match is made. POST , PUT , PATCH , DELETE etc. all work in similar fashion. The subdomain optional argument limits the matching to a subdomain. router.HTTP(url: str, handler: func) -> Registers your custom handlers/functions to all HTTP methods i.e. GET, PUT, POST, PUT, PATCH instead of doing it individually. router.keep(key: str, value: any) -> Like. c.keep() but persisted across multiple request lifecycles. router.peek(key: str, value: any) -> Take a peek at your global dynamic application state without removing the kept value. router.unkeep(key: str, value: any) -> Remove and return the kept value from the global dynamic application state. Minute 5 : FAQs Anyone? Whew... You made it here, we are super proud of you. One last thing and you will be all set to create anything with a shiny powerful web framework. It's time to answer your questions. What of authentication and authorization? Routerling is a microframwork so you have to roll your own which is pretty simple to do with python decorators .","title":"Quickstart"},{"location":"quickstart/#minute-1","text":"We are assuming you have installed routerling via pip install routerling . If no, then go ahead and install it; If you have, then the clock is ticking so let's dive in.","title":"Minute 1"},{"location":"quickstart/#1-create-a-handler-function","text":"import json from http import HTTPStatus from routerling import HttpRequest, ResponseWriter, Context async def get_one_customer(r: HttpRequest, w: ResponseWriter, c: Context): id = r.params.get('id') w.status = HTTPStatus.CREATED w.body = json.dumps({\"message\": f\"routerling is easy for customer {id}\"}) As you can see above - your handler function can be async if you desire and must accept 3 arguments that will be injected by routerling. We'll get back to them in Minute 3","title":"1. Create a handler function"},{"location":"quickstart/#2-connect-your-handler-to-the-routerling-application","text":"from routerling import Router # create the application router = Router() # connect it to a route router.GET('/v1/customers/:id', get_one_customer) All HTTP methods i.e. GET , POST etc. are all supported","title":"2. Connect your handler to the routerling application"},{"location":"quickstart/#minute-2","text":"That was quick wasn't it? even less than a minute? Well now we have an application, but it is no fun if we can't execute/run/interact with it.","title":"Minute 2"},{"location":"quickstart/#3-run-your-routerling-application","text":"# development uvicorn application:router --reload # production gunicorn -w 4 -k uvicorn.workers.UvicornWorker application:router Replace the number after -w with the number of processors you desire to run your app with. !!! info \"Slow Down Tiger\" You might be asking - what about the applications port number etc? \ud83d\ude01","title":"3. Run your routerling application"},{"location":"quickstart/#minute-3-4","text":"A promise is a promise. So it's time to tell you about routerling's objects. Don't fret - there are only 4 of them.","title":"Minute 3 &amp; 4"},{"location":"quickstart/#1-httprequest","text":"All handlers will receive this as their first argument i.e. ...(r: HttpRequest, ..., ...) and all HttpRequest objects come with the following bag of goodies. r.app: Router -> An instance of the base routerling application r.body: dict -> The body sent along with the request r.cookies: dict -> All the cookies sent with request [keys in lowercase] r.headers: dict -> All the headers sent with request [keys in lowercase] r.method: str -> GET , POST , DELETE ? What method type is the http request r.params: dict -> Querystring parameters and url masks /customers/:param1 parsed into a dictionary r.querystring: str -> The part after the ? i.e. example.com ?age=34 parsed in comma separated string form r.subdomain: str -> If request was made to a subdomain i.e. www.example.org or api.example.org then this holds the subdomain value e.g. www and api . r.url: str -> The url that matched to this handler as sent by the client","title":"1. HttpRequest"},{"location":"quickstart/#2-responsewriter","text":"All handlers receive this as the second argument i.e. ...(..., w: ResponseWriter, ...) as ResponseWriters help with responding to HttpRequests. w.abort(payload: any) -> If this is calledx then all PRE and POST hooks will be aborted w.body: any -> This will be sent back as the body of the response w.headers: tuple[2] | list[2] -> How headers are set i.e. w.headers = 'Set-Cookie', 'Token=12345; Max-Age=8700; Secure; HttpOnly' w.status: int -> HTTP status code to be sent back with the response","title":"2. ResponseWriter"},{"location":"quickstart/#3-context","text":"All handlers receive this as the third argument i.e. ...(..., ..., c: Context) to help with preserving state across a request lifecycle i.e. from start/reciept to finish/response. c.keep(alias: str, value: any) -> Save something that can be retrieved via Python descriptor semantics. i.e. c.alias will return the kept value.","title":"3. Context"},{"location":"quickstart/#4-router","text":"This is the last internal routerling object to grok. You can instantiate it with an optional configuration that is stored as the application's global state. router = Router({'secret_key': '...'}) # or router = Router(function() -> dict) router.AFTER(url: str, handler: func, subdomain: str) -> Register a handler to run after all matches to the provided url i.e. router.AFTER('/v1/*', log_visit_in_db) router.BEFORE(url: str, handler: func, subdomain: str) -> Get a config value from the global store/state register router.CONFIG(url: str, handler: func, subdomain: str) -> Get a config value from the final readonly app config set at router instantiation. router.GET(url: str, handler: func, subdomain: str) -> Registers your custom handlers/functions to be invoked when a url match is made. POST , PUT , PATCH , DELETE etc. all work in similar fashion. The subdomain optional argument limits the matching to a subdomain. router.HTTP(url: str, handler: func) -> Registers your custom handlers/functions to all HTTP methods i.e. GET, PUT, POST, PUT, PATCH instead of doing it individually. router.keep(key: str, value: any) -> Like. c.keep() but persisted across multiple request lifecycles. router.peek(key: str, value: any) -> Take a peek at your global dynamic application state without removing the kept value. router.unkeep(key: str, value: any) -> Remove and return the kept value from the global dynamic application state.","title":"4. Router"},{"location":"quickstart/#minute-5-faqs-anyone","text":"Whew... You made it here, we are super proud of you. One last thing and you will be all set to create anything with a shiny powerful web framework. It's time to answer your questions. What of authentication and authorization? Routerling is a microframwork so you have to roll your own which is pretty simple to do with python decorators .","title":"Minute 5 : FAQs Anyone?"},{"location":"samples/","text":"Before you go... How about some cheat codes ;-) We use routerling extensively to power numerous enterprise microservices and have collated some practices that might help you get there even faster. Decorators In this example we use the jsonschema library to pass along validated data to our eventual handlers from asyncio import iscoroutinefunction from functools import wraps from http import HTTPStatus from jsonschema import validate from jsonschema.exceptions import ValidationError from ujson import dumps, loads def expects(schema: dict): def wrapper(func): @wraps(func) async def delegate(r: HttpRequest, w: ResponseWriter, c: Context): try: json = loads(r.body) except: return w.status = HTTPStatus.UNPROCESSABLE_ENTITY try: validate(schema, json, draft7_format_checker=True) except ValidationError as exc: w.body = dumps(exc) return w.status = status.BAD_REQUEST # little helper used in example handler below -> c.age, c.email for key in json: c.keep(key, json.get(key)) # so you can wrap async and non async handler variants if iscoroutinefunction(func): return await func(r, w, c) else: return func(r, w, c) return delegate return wrapper @expects({ 'type': 'object', 'properties': { 'age': {'type': 'number', 'min': 18, 'max': 180}, 'email': {'type': 'string', 'format': 'email'} }, 'required': ['age', 'email'], 'additionalProperties': false, }) async def create_customer_order(r: HttpRequest, w: ResponseWriter, c: Context): dbpool = r.app.peek('dbpool') async with dbpool.acquire() as sqld: try: identifier = sqld.execute('... returning id') except UniqueViolationsError: return w.status = status.SERVICE_UNAVAILABLE w.status = HTTPStatus.CREATED w.body = dumps({ 'identifier': identifier, 'age': c.age, 'email': c.email }) This example demonstrates one of the ways Authentication might be implemented with the pyjwt library. from asyncpg import Pool from jwt import decode def private(role: str): \"\"\"RBAC Authorization, routerling makes it easy to also use ABAC\"\"\" def wrapper(func): @wraps(func) def delegate(r: HttpRequest, w: ResponseWriter, c: Context): dbpool: Pool = r.app.peek('dbpool') with dbpool.acquire() as sqld: try: roles = await sqld.fetchval(\"\"\" SELECT roles FROM privileges WHERE user = $1 AND action = $2 \"\"\", c.current_user, f'{r.method.lower()}s') except: w.status = HTTPStatus.SERVICE_UNAVAILABLE w.body = dumps({'message': 'please try again later'}) if role in roles: return await func(r, w, c) w.status = HTTPStatus.UNAUTHORIZED w.body = dumps({'message': 'insufficient privileges'}) return delegate return wrapper def protected(func): \"\"\"Authentication\"\"\" @wraps(func) def delegate(r: HttpRequest, w: ResponseWriter, c: Context): token = r.headers.get('authorization') secret_key = r.app.CONFIG('SECRET_KEY') try: credentials = decode(token, secret_key, algorithm='HS256') except: return w.status = status.UNAUTHORIZED else: c.keep('current_user') = credentials.get('id') return await func(r, w, c) return delegate","title":"Samples"},{"location":"samples/#before-you-go-how-about-some-cheat-codes-","text":"We use routerling extensively to power numerous enterprise microservices and have collated some practices that might help you get there even faster.","title":"Before you go... How about some cheat codes ;-)"},{"location":"samples/#decorators","text":"In this example we use the jsonschema library to pass along validated data to our eventual handlers from asyncio import iscoroutinefunction from functools import wraps from http import HTTPStatus from jsonschema import validate from jsonschema.exceptions import ValidationError from ujson import dumps, loads def expects(schema: dict): def wrapper(func): @wraps(func) async def delegate(r: HttpRequest, w: ResponseWriter, c: Context): try: json = loads(r.body) except: return w.status = HTTPStatus.UNPROCESSABLE_ENTITY try: validate(schema, json, draft7_format_checker=True) except ValidationError as exc: w.body = dumps(exc) return w.status = status.BAD_REQUEST # little helper used in example handler below -> c.age, c.email for key in json: c.keep(key, json.get(key)) # so you can wrap async and non async handler variants if iscoroutinefunction(func): return await func(r, w, c) else: return func(r, w, c) return delegate return wrapper @expects({ 'type': 'object', 'properties': { 'age': {'type': 'number', 'min': 18, 'max': 180}, 'email': {'type': 'string', 'format': 'email'} }, 'required': ['age', 'email'], 'additionalProperties': false, }) async def create_customer_order(r: HttpRequest, w: ResponseWriter, c: Context): dbpool = r.app.peek('dbpool') async with dbpool.acquire() as sqld: try: identifier = sqld.execute('... returning id') except UniqueViolationsError: return w.status = status.SERVICE_UNAVAILABLE w.status = HTTPStatus.CREATED w.body = dumps({ 'identifier': identifier, 'age': c.age, 'email': c.email }) This example demonstrates one of the ways Authentication might be implemented with the pyjwt library. from asyncpg import Pool from jwt import decode def private(role: str): \"\"\"RBAC Authorization, routerling makes it easy to also use ABAC\"\"\" def wrapper(func): @wraps(func) def delegate(r: HttpRequest, w: ResponseWriter, c: Context): dbpool: Pool = r.app.peek('dbpool') with dbpool.acquire() as sqld: try: roles = await sqld.fetchval(\"\"\" SELECT roles FROM privileges WHERE user = $1 AND action = $2 \"\"\", c.current_user, f'{r.method.lower()}s') except: w.status = HTTPStatus.SERVICE_UNAVAILABLE w.body = dumps({'message': 'please try again later'}) if role in roles: return await func(r, w, c) w.status = HTTPStatus.UNAUTHORIZED w.body = dumps({'message': 'insufficient privileges'}) return delegate return wrapper def protected(func): \"\"\"Authentication\"\"\" @wraps(func) def delegate(r: HttpRequest, w: ResponseWriter, c: Context): token = r.headers.get('authorization') secret_key = r.app.CONFIG('SECRET_KEY') try: credentials = decode(token, secret_key, algorithm='HS256') except: return w.status = status.UNAUTHORIZED else: c.keep('current_user') = credentials.get('id') return await func(r, w, c) return delegate","title":"Decorators"}]}