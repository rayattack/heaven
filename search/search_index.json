{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The Developer Experience Dream","text":"<p>Heaven was born from a simple dream: You shouldn't need a PhD in web development to build an enterprise web application</p> <p>Web development is like a chess board. Many frameworks expect you to be Magnus Carlsen before you can play (create) a legendary game (web application).</p> <p>Most modern frameworks are like a crowded room shouting suggestions at you. They try to be everything for everyone. They bury you in layers of abstraction until you forget what HTTP looks like.</p> <p>Heaven is different.</p> <p>It gives you raw, unadulterated power and gets out of your way immediately with a syntax designed for an average developer to understand in 10 minutes or less.</p> <p>yourapp/app.py <pre><code>from heaven import Router\n\n# create the application\napp = Router()\n\n# define a route and tell heaven where it can find your handler\napp.GET('/v1/games/:id', 'controllers.games.play_a_game')\n</code></pre></p> <p>yourapp/controllers/games.py <pre><code>def play_a_game(req, res, ctx):\n  res.body = 'Checkmate.'\n</code></pre></p>"},{"location":"#why-another-python-framework","title":"Why Another Python Framework?","text":"<p>Tired of Flask's thread-local magic and aging internals. Tired of Django's monolithic weight. Tired of FastAPI's dependency injection labyrinth?</p> <p>Looking for something Powerful and lightning Fast. A framework that You won't spend months learning, cos life is too short - and more importantly years mastering?</p> <p>... then you belong in Heaven.</p>"},{"location":"#your-10-minute-path-to-mastery","title":"Your 10-Minute Path to Mastery","text":"<p>Because Heaven relies on standard Python and pure HTTP concepts, you don't need a 500-page manual. You need 10 minutes.</p> <ul> <li>Minute 1: The Beginning - From Zero to Hello World.</li> <li>Minute 2: The Command Line - Controlling the skies with <code>fly</code> and <code>run</code>.</li> <li>Minute 3: The Router - Understanding the nervous system of your app.</li> <li>Minute 4: The Request - Reading the user's mind.</li> <li>Minute 5: The Response - Speaking back with authority.</li> <li>Minute 6: The Context - Managing state like a pro.</li> <li>Minute 7: Schema &amp; Docs - Automatic validation and interactive docs.</li> <li>Minute 8: The Earth - Testing your world without leaving it.</li> <li>Minute 9: Deployment - Going live.</li> <li>Minute 10: Mastery - The final word.</li> </ul>"},{"location":"#ready-to-play","title":"Ready to Play?","text":"<pre><code>$ pip install heaven\n</code></pre> <pre><code>from heaven import App\n\n# For instance if this app could talk it might tell you:\n# Hello my name is `your-app` - I am a Python web application\n# I spend my time serving web requests and \n# when I am free - I spend my time dreaming of becoming a chess engine\napp = App()\n\n# The move is yours.\napp.GET('/', lambda req, res, ctx: res.json({'message': 'Checkmate.'}))\n</code></pre>"},{"location":"api/","title":"Heaven API Reference \ud83d\udcd6","text":"<p>A comprehensive guide to every method, property, and constant in the Heaven framework.</p>"},{"location":"api/#app-router","title":"App / Router","text":"<p>The central orchestrator of your application.</p>"},{"location":"api/#app-routerprotect_outputtrue","title":"<code>App()</code> / <code>Router(protect_output=True, ...)</code>","text":"<p>Initialize the framework.  - <code>protect_output</code>: (Default <code>True</code>) Enables <code>msgspec</code> validation/projection. - <code>fail_on_output</code>: (Default <code>False</code>) Determines if individual validation errors should crash the request or just log a warning.</p>"},{"location":"api/#routing-methods","title":"Routing Methods","text":"<p>All methods follow the signature: <code>(url: str, handler: Callable, subdomain: str = DEFAULT)</code> - <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>PATCH</code>, <code>HEAD</code>, <code>OPTIONS</code>, <code>CONNECT</code>, <code>TRACE</code> - <code>HTTP(url, handler)</code>: Registers all the above methods at once. - <code>SOCKET(url, handler)</code>: Registers a WebSocket handler.</p>"},{"location":"api/#hooks-lifecycle","title":"Hooks &amp; Lifecycle","text":"<ul> <li><code>BEFORE(url, handler)</code>: Runs before matching routes.</li> <li><code>AFTER(url, handler)</code>: Runs after matching routes.</li> <li><code>ON(event, handler)</code>: Lifecycle hooks for <code>STARTUP</code> and <code>SHUTDOWN</code>.</li> </ul>"},{"location":"api/#utilities","title":"Utilities","text":"<ul> <li><code>mount(url, other_router)</code>: Nest applications.</li> <li><code>daemon(coroutine)</code>: Register background tasks that run with the server lifecycle.</li> <li><code>listen(host, port)</code>: shortcut for <code>uvicorn.run</code>.</li> <li><code>openapi()</code>: Generates the OpenAPI spec dictionary.</li> <li><code>DOCS(url)</code>: Serves the Swagger/OpenAPI UI.</li> </ul>"},{"location":"api/#request-req","title":"Request (<code>req</code>)","text":"<p>The object representing an incoming HTTP or WebSocket request.</p> <ul> <li><code>req.app</code>: Access the parent <code>Router</code> instance.</li> <li><code>req.method</code>: <code>str</code> (GET, POST, etc.)</li> <li><code>req.url</code>: <code>str</code> (Relative path)</li> <li><code>req.headers</code>: <code>dict</code>-like access to headers.</li> <li><code>req.cookies</code>: Parsed <code>dict</code> of cookies.</li> <li><code>req.params</code>: <code>dict</code> of URL parameters (e.g., <code>:id</code>).</li> <li><code>req.queries</code>: <code>dict</code> of query string parameters.</li> <li><code>req.json</code>: Body decoded via <code>msgspec</code>.</li> <li><code>req.data</code>: Validated/Structured body data (if <code>Schema</code> is used).</li> <li><code>req.form</code>: Parsed <code>multipart</code> or <code>urlencoded</code> data.</li> <li><code>req.ip</code>: Client IP address info.</li> <li><code>req.subdomain</code>: Current subdomain string.</li> </ul>"},{"location":"api/#response-res","title":"Response (<code>res</code>)","text":"<p>Used to send data back to the client. All methods return <code>self</code> for chaining.</p> <ul> <li><code>res.status = 200</code>: Set HTTP status code.</li> <li><code>res.body = \"data\"</code>: Set the response body.</li> <li><code>res.json()</code>: Returns/sets body as JSON.</li> <li><code>res.text()</code>: Returns/sets body as text.</li> <li><code>res.header(key, val)</code>: Set a header.</li> <li><code>res.cookie(key, val, ...)</code>: Set a cookie.</li> <li><code>res.renders(template, **data)</code>: Render a Jinja2 template.</li> <li><code>res.file(path)</code>: Serve a static file.</li> <li><code>res.stream(gen, sse=False)</code>: Stream an async generator (with optional SSE formatting).</li> <li><code>res.abort(body=None)</code>: Stop execution and return immediately.</li> </ul>"},{"location":"api/#context-ctx","title":"Context (<code>ctx</code>)","text":"<p>Shared state container for the duration of a request.</p> <ul> <li><code>ctx.keep(key, val)</code>: Store a value.</li> <li><code>ctx.peek(key)</code>: Retrieve a value.</li> <li><code>ctx.unkeep(key)</code>: Remove and return a value.</li> <li><code>ctx.something</code>: Property-style access to kept values.</li> </ul>"},{"location":"api/#earth","title":"Earth","text":"<p>The integration testing engine. Access via <code>router.earth</code>.</p> <ul> <li><code>earth.GET(url, ...)</code> / <code>earth.POST(...)</code>: Simulate requests.</li> <li><code>earth.upload(url, files=...)</code>: Multipart upload helper.</li> <li><code>earth.SOCKET(url)</code>: WebSocket simulation client.</li> <li><code>earth.test(track_session=True)</code>: Context manager for full lifecycle + session tests.</li> </ul>"},{"location":"cli/","title":"Minute 2: The Command Line \ud83d\udee0\ufe0f","text":"<p>In Minute 1, you met <code>heaven fly</code>. But you don't just want to fly, you want to pilot. Heaven's CLI is your cockpit. It is precise, informative, and explicitly typed.</p>"},{"location":"cli/#the-heaven-command","title":"The <code>heaven</code> Command","text":"<p>Type <code>heaven</code> (or <code>heaven -h</code>) to see your controls.</p> <pre><code>$ heaven\nusage: heaven [-h] {fly,run,routes,handlers,schema} ...\n\nHeaven CLI - The divine interface for your web framework.\n\npositional arguments:\n  {fly,run,routes,handlers,schema}\n                        Available commands\n    fly                 Zero-config auto-discovery run\n    run                 Run a specific application\n    routes              Show all registered routes\n    handlers            Deep inspection of handlers\n    schema              Export OpenAPI spec to JSON\n</code></pre>"},{"location":"cli/#1-zero-config-heaven-fly","title":"1. Zero-Config: <code>heaven fly</code>","text":"<p>The <code>fly</code> command is for when you just want to code. It automatically hunts for <code>app.py</code>, <code>main.py</code>, or similar files in your current directory and launches the first <code>App</code> or <code>Router</code> instance it finds.</p> <pre><code># Just fly.\n$ heaven fly\n\n# Fly on a different port.\n$ heaven fly --port 8080 --host 0.0.0.0\n</code></pre> <p>[!NOTE] <code>heaven fly</code> always enables auto-reload. It is designed for development.</p>"},{"location":"cli/#2-explicit-control-heaven-run","title":"2. Explicit Control: <code>heaven run</code>","text":"<p>When you go to production or have a complex project structure, you need <code>run</code>. This command stops the magic guessing game and does exactly what you tell it.</p> <pre><code># Run the 'app' object in 'main.py'\n$ heaven run main:app\n\n# Production mode (no reload, multiple workers)\n# Note: Heaven wraps uvicorn, so for advanced deployment you can use uvicorn directly too.\n$ heaven run main:app --no-reload --host 0.0.0.0 --port 80\n</code></pre>"},{"location":"cli/#3-deep-introspection","title":"3. Deep Introspection","text":"<p>Heaven wants you to know your app better than you know yourself.</p>"},{"location":"cli/#view-your-routes","title":"View Your Routes","text":"<p>See every path, method, subdomain, and protection status in a beautiful table.</p> <pre><code>$ heaven routes\n# or specify the app path explicitly\n$ heaven routes --app main:app\n</code></pre>"},{"location":"cli/#inspect-your-handlers","title":"Inspect Your Handlers","text":"<p>Have you ever forgotten where a specific endpoint is defined? <code>handlers</code> tunnels through decorators, partials, and closures to find the original source code.</p> <pre><code># Interactive map of all handlers and their file locations\n$ heaven handlers\n\n# View the source code of a specific handler right in your terminal\n$ heaven handlers /api/users\n</code></pre>"},{"location":"cli/#export-schema","title":"Export Schema","text":"<p>Need your OpenAPI spec for a CI pipeline or client generator?</p> <pre><code>$ heaven schema\n# outputs to swagger.json by default\n\n$ heaven schema openapi-v1.json\n</code></pre> <p>Next: Now that you can control the server, let's learn how to direct the traffic. On to Minute 3: The Router.</p>"},{"location":"coffee/","title":"Sip some coffee \u2615\ufe0f","text":"<p>You've made it through the core of Heaven! </p> <p>By now, you should feel comfortable with: - Handling Requests - Sending Responses - Managing State via Context - Mounting Apps &amp; Using Daemons</p> <p>Take a moment to enjoy the simplicity. When you're ready, we'll dive into the advanced features and the Full API Reference.</p>"},{"location":"congrats/","title":"Minute 10: Mastery \ud83c\udfc6","text":"<p>Checkmate.</p> <p>You have traversed the board. You know the opening (<code>fly</code>), the mid-game (<code>router</code>, <code>schema</code>), and the endgame (<code>deployment</code>).</p> <p>You are no longer just a Python developer. You are a Heaven Master.</p>"},{"location":"congrats/#the-future","title":"The Future","text":"<p>This documentation is short because the framework is simple. But simplicity does not mean weakness. Heaven is capable of powering everything from microservices to massive monolithic platforms.</p> <p>Go forth and build something divine.</p> <p>\"Simplicity is the ultimate sophistication.\" \u2014 Leonardo da Vinci</p>"},{"location":"congrats/#where-to-go-from-here","title":"Where to go from here?","text":"<ul> <li>API Reference: The raw dictionary of every method.</li> <li>Examples: Real-world patterns and recipes.</li> <li>GitHub: Star the repo, file an issue, or contribute.</li> </ul> <p>May your response times be low and your uptime high. \u26a1</p>"},{"location":"context/","title":"Minute 6: The Context \ud83e\udde0","text":"<p>The <code>Context</code> object is your request-scoped memory. It allows you to pass data between hooks, middlewares, and handlers without cluttering function signatures.</p> <p>The handler signature:</p> <pre><code>async def handler(req, res, ctx):\n    ...\n</code></pre>"},{"location":"context/#usage","title":"Usage","text":""},{"location":"context/#storing-data","title":"Storing Data","text":"<p>Use <code>ctx.keep(key, value)</code> to store data.</p> <pre><code>app.BEFORE('/dashboard/*', auth_middleware)\n\nasync def auth_middleware(req, res, ctx):\n    user = await db.get_user(req.headers['token'])\n    ctx.keep('user', user)\n</code></pre>"},{"location":"context/#retrieving-data","title":"Retrieving Data","text":"<p>Once stored, data is available as a property on the <code>ctx</code> object.</p> <pre><code>async def dashboard_handler(req, res, ctx):\n    # Retrieve 'user' stored by auth_middleware\n    print(f\"Welcome back {ctx.user.name}\")\n</code></pre>"},{"location":"context/#why-not-modifies-req","title":"Why not modifies <code>req</code>?","text":"<p>Some frameworks attach data to the <code>Request</code> object. Heaven believes in separation of concerns. - Request: What the client sent (Immutable-ish). - Context: What the server figured out (Mutable).</p> <p>Next: We've covered the basics. Now let's superpower your app with Schemas. On to Minute 7: Schema &amp; Docs.</p>"},{"location":"deployment/","title":"Minute 9: Deployment \ud83d\ude80","text":"<p>You have built a masterpiece. Now it must scale.</p> <p>Heaven is built on top of ASGI (Asynchronous Server Gateway Interface), which means it can be served by any industry-standard ASGI server like <code>uvicorn</code>, <code>hypercorn</code>, or <code>daphne</code>.</p>"},{"location":"deployment/#method-1-the-heaven-way","title":"Method 1: The Heaven Way","text":"<p>The simplest way to deploy is using the built-in CLI, which wraps <code>uvicorn</code> with optimal defaults.</p> <pre><code>$ heaven run main:app --host 0.0.0.0 --port 80 --no-reload --workers 4\n</code></pre> <ul> <li><code>--no-reload</code>: Vital for production performance.</li> <li><code>--workers 4</code>: Run multiple processes to utilize all CPU cores.</li> </ul>"},{"location":"deployment/#method-2-gunicorn-the-pro-way","title":"Method 2: Gunicorn (The Pro Way)","text":"<p>For robust process management, <code>gunicorn</code> with <code>uvicorn</code> workers is the industry standard.</p> <pre><code>$ pip install gunicorn\n$ gunicorn main:app -w 4 -k uvicorn.workers.UvicornWorker -b 0.0.0.0:80\n</code></pre>"},{"location":"deployment/#method-3-docker","title":"Method 3: Docker","text":"<p>Keep it contained.</p> <pre><code>FROM python:3.9-slim\n\nWORKDIR /app\nCOPY . .\nRUN pip install heaven\n\n# Run via Heaven CLI\nCMD [\"heaven\", \"run\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"80\", \"--no-reload\"]\n</code></pre>"},{"location":"deployment/#reverse-proxy","title":"Reverse Proxy","text":"<p>Always put Nginx or Caddy in front of your Heaven app to handle SSL, static assets, and load balancing.</p> <p>Next: You made it. On to Minute 10: Mastery.</p>"},{"location":"earth/","title":"Minute 8: The Earth \ud83c\udf0d","text":"<p>Testing web apps usually involves spinning up a \"test client\", fiddling with ports, or mocking complex internal states. Heaven gives you <code>Earth</code>, a testing utility that lets you verify your world without leaving Python.</p>"},{"location":"earth/#the-testing-philosophy","title":"The Testing Philosophy","text":"<p>Heaven tests are:</p> <ol> <li> <p>In-Process: No network overhead.</p> </li> <li> <p>Explicit: You see exactly what <code>req</code>, <code>res</code>, and <code>ctx</code> look like.</p> </li> <li> <p>Flexible: Test full lifecycles or atomic functions.</p> </li> </ol>"},{"location":"earth/#1-full-integration-tests","title":"1. Full Integration Tests","text":"<p>Use the <code>test()</code> context manager to simulate a real server environment (including startup/shutdown hooks).</p> <pre><code># test_app.py\nfrom main import app\n\nasync def test_create_user():\n    async with app.earth.test() as earth:\n        # 1. Send Request\n        req, res, ctx = await earth.POST('/users', body={'name': 'Ray'})\n\n        # 2. Assert Response\n        assert res.status == 201\n        assert res.json['name'] == 'Ray'\n</code></pre>"},{"location":"earth/#2-unit-testing-handlers","title":"2. Unit Testing Handlers","text":"<p>Sometimes you just want to test a single function without running the whole router logic.</p> <pre><code>from main import create_user_handler\n\nasync def test_handler_logic():\n    # 1. Create fake components\n    req = app.earth.req(url='/', body={'name': 'Ray'})\n    res = app.earth.res()\n    ctx = app.earth.ctx()\n\n    # 2. Call handler directly\n    await create_user_handler(req, res, ctx)\n\n    # 3. Verify\n    assert res.status == 201\n</code></pre>"},{"location":"earth/#3-mocking-swapping","title":"3. Mocking &amp; Swapping","text":"<p>You often need to mock databases or external services.</p>"},{"location":"earth/#bucket-mocking","title":"Bucket Mocking","text":"<p>If your app uses <code>app.peek('db')</code>, you can overwrite it for the test.</p> <pre><code>async with app.earth.test() as earth:\n    # Overwrite the database connection\n    app.keep('db', MockDatabase())\n\n    await earth.GET('/users')\n</code></pre>"},{"location":"earth/#hook-swapping","title":"Hook Swapping","text":"<p>Swap out a startup hook (like <code>connect_db</code>) with a mock version.</p> <pre><code># The real startup hook\nasync def connect_prod_db(app): ...\n\n# The test startup hook\nasync def connect_test_db(app): ...\n\n# Swap them\napp.earth.swap(connect_prod_db, connect_test_db)\n</code></pre>"},{"location":"earth/#4-subdomains-websockets","title":"4. Subdomains &amp; WebSockets","text":"<p>Earth handles everything Heaven handles.</p> <pre><code># Test a subdomain\nawait earth.GET('/admin', subdomain='admin')\n\n# Test a WebSocket\nws = await earth.SOCKET('/chat').connect()\nawait ws.send('hello')\nassert await ws.receive() == 'world'\nawait ws.close()\n</code></pre> <p>Next: It works locally. Let's show the world. On to Minute 9: Deployment.</p>"},{"location":"examples/","title":"Appendix&colon; Examples","text":""},{"location":"examples/#how-tos-and-code-examples","title":"How-To's and Code Examples","text":"<p>Heaven is currently being used in production by a few customer facing web products and to power high performance microservices. Below are some of the observations and collated practices that might help provide some guidance on code patterns possible in heaven.</p>"},{"location":"examples/#decorator-functions","title":"Decorator Functions","text":"<p>Useful for intercepting and performing actions before the decorated function is invoked i.e. <code>authentication</code>, <code>dependency injection</code>, or <code>authorization</code> amongst other possibilities.</p> <p>This example demonstrates one of the ways Authentication might be implemented with the <code>pyjwt</code> library. <pre><code>from asyncpg import Pool\nfrom jwt import decode\n\n\ndef protected(func):\n    \"\"\"Authentication\"\"\"\n    @wraps(func)\n    def delegate(r: Request, w: Response, c: Context):\n        token = r.headers.get('authorization')\n        secret_key = r.app.CONFIG('SECRET_KEY')\n\n        try: credentials = decode(token, secret_key, algorithm='HS256')\n        except: return w.status = status.UNAUTHORIZED\n        else: c.keep('current_user') = credentials.get('id')\n\n        return await func(r, w, c)\n    return delegate\n\n\ndef private(resource: str):\n    \"\"\"RBAC Authorization, heaven makes it easy to also use ABAC\"\"\"\n    def wrapper(func):\n        @wraps(func)\n        def delegate(r: Request, w: Response, c: Context):\n            dbpool: Pool = r.app.peek('dbpool')\n            action = r.method.lower()\n            with dbpool.acquire() as sqld:\n                try: roles = await sqld.fetchval(\"\"\"\n                    SELECT roles\n                    FROM privileges\n                    WHERE user = $1 AND action = $2 AND resource = $3\n                \"\"\", c.current_user, action, resource)\n                except:\n                    w.status = HTTPStatus.SERVICE_UNAVAILABLE\n                    w.body = dumps({'message': 'please try again later'})\n            if action in roles: return await func(r, w, c)\n\n            w.status = HTTPStatus.UNAUTHORIZED\n            w.body = dumps({'message': 'insufficient privileges'})\n        return delegate\n    return wrapper\n</code></pre></p>"},{"location":"examples/#schema-validation-documentation","title":"Schema Validation &amp; Documentation","text":"<p>Use <code>router.schema</code> to define your API contracts and <code>router.DOCS</code> to generate interactive documentation.</p> <pre><code>from heaven import App, Schema\n\napp = App()\n\nclass User(Schema):\n    id: int\n    email: str\n    role: str = \"guest\"\n\n# Define your handler\nasync def create_user(req, res, ctx):\n    user = req.data # Validated User struct\n    print(f\"Creating user: {user.email}\")\n    res.body = {\"status\": \"created\", \"id\": 123}\n\n# 1. Register endpoint metadata\napp.schema.POST(\n    '/v1/users', \n    expects=User, \n    returns=dict, \n    summary=\"Create a new user\",\n    description=\"Creates a guest user by default if role is not provided.\"\n)\n\n# 2. Register handler\napp.POST('/v1/users', create_user)\n\n# 3. Enable Scalar Documentation\napp.DOCS('/api/docs', title=\"User Service API\")\n</code></pre> <p>The above setup provides: - Automatic 422 errors for invalid JSON. - Static typing in your handler via <code>req.data</code>. - Interactive docs at <code>/api/docs</code>.</p>"},{"location":"html/","title":"Minute 6: Rendering HTML","text":"<p>Heaven uses Jinja as its templating engine. This however does not stop you from rolling your own preferred template engine.</p> <p>You can render html templates in <code>asynchronous</code> or <code>asyncrhonous=False</code> modes.</p> <pre><code>from routerling import Application\n\napplication = Application()\n\n# application.TEMPLATES('my/templates/folder', asynchronous=False)\napplication.TEMPLATES('my/templates/folder')  # asynchronous=True\n\n\nasync def index(req, res, ctx):\n    ctx.keep('message', 'Hello world!')\n    await res.render('index.html', req=req, my_name='Santa')\n\n\napplication.GET('/', index)\n</code></pre> <p>In your <code>index.html</code> file <code>Note:</code> heaven will inject <code>ctx</code> automatically: <pre><code>&lt;h1&gt;{{ ctx.message }}&lt;/h1&gt;&lt;!-- injected by heaven automatically --&gt;\n&lt;p&gt;{{ my_name }}&lt;/p&gt;&lt;!-- you injected this manually --&gt;\n</code></pre></p> <p>You can also pass additional arguments <code>response.render('', *args)</code> the rendered template as is.</p> <p>For more see tutorial - how to use Jinja.</p>"},{"location":"mount/","title":"Mounting Routers","text":"<p>Heaven allows for applications to be mounted on top of each other. See example below</p> <p>First let's create our backend api as a heaven application/router in a file called:</p> <p><code>api.py</code> <pre><code>from heaven import Router\n\napi = Router()\napi.GET('/v1/customers', lambda req, res, ctx:...)\n</code></pre></p> <p>Next we create our frontend renderer as another heaven application/router:</p> <p><code>pages.py</code> <pre><code>from heaven import Router\n\npages = Router()\n\n# folder where your templates are stored\npages.TEMPLATES('templates', asynchronous=False)\npages.ASSETS('assets')\n\n\npages.GET('/', lambda req, res, ctx: res.renders('index.html'))\n</code></pre></p> <p>Finally we create our main heaven application that will configure database connections and mount the <code>backend app</code> and <code>frontend app</code> on itself as mounted children:</p> <p><code>app.py</code> <pre><code>from heaven import Application\n\napp = Application()\n\napp.mount(api, isolated=True)\napp.mount(pages, isolated=False)\n</code></pre> isolation=False means no middlewares, config, or state is shared between router instances - only routes will be mounted.</p>"},{"location":"quickstart/","title":"Minute 1: The Beginning \u26a1","text":"<p>The clock is ticking. 60 seconds to a running server.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<pre><code>$ pip install heaven\n</code></pre>"},{"location":"quickstart/#the-first-move","title":"The First Move","text":"<p>Create a file named <code>app.py</code>:</p> <pre><code>from heaven import App\n\napp = App()\n\n# Handlers receive 3 arguments: Request, Response, Context\nasync def hello(req, res, ctx):\n    res.body = \"Hello from Heaven\"\n\n# Map the URL '/' to the 'hello' handler\napp.GET('/', hello)\n</code></pre>"},{"location":"quickstart/#lift-off","title":"Lift Off","text":"<p>In your terminal, run:</p> <pre><code>$ heaven fly\n</code></pre> <p>You should see: <pre><code>INFO:     Started server process [1234]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n</code></pre></p> <p>Open your browser to <code>http://localhost:8000</code>.  Congratulations. Only 9 minutes left.</p> <p>Next: You're flying, but now let's take control. On to Minute 2: The Command Line.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#alphabetical-list-of-all-heaven-apis","title":"Alphabetical List of All Heaven APIs","text":"<ul> <li> <p><code>constants.DEFAULT</code> -&gt; A <code>str</code> constant helpful to preven you from typing <code>'www'</code> everywhere in your code.</p> </li> <li> <p><code>constants.WILDCARD</code> -&gt; A <code>str</code> constant helpful to prevent you from typing <code>'*'</code> everywhere in your code.</p> </li> <li> <p><code>context.keep(key: str, value: any)</code> -&gt; This is how values are kept/stored in the context API for use across http requests.     see decorator code snippet for example on its usage</p> </li> <li> <p><code>form.Form</code> -&gt; Tiny wrapper around a dict returned from <code>req.FORM</code> when content-type of request is of type <code>multitype/form-data</code> or     <code>application/x-www-form-urlencoded</code> <pre><code>from heaven.form import Form\n\nHEADERS = ['multitype/form-data', 'application/x-www-form-urlencoded']\n\nasync def example(req, res, ctx):\n    if(req.headers.get('content-type') in HEADERS):\n        isinstance(req.form, Form)  # --&gt; True\n        print(form.email)\n        print(form.password)\n    else:\n        assert req.form is None  # --&gt; True\n</code></pre></p> </li> <li> <p><code>router.AFTER(url: str, handler: func, subdomain: str)</code> -&gt; This is called a hook - a function that is hooked to run after all matching routes.     <pre><code>message = 'I will run after all /v1/* routes'\nrouter.AFTER('/v1/*', lambda req, res, ctx: print(message))\n\n# will run after\nrouter.GET('/v1/customers', ...)\nrouter.POST('/v1/leads', ...)\n\n# but not after\nrouter.GET('/v2/customers')\n</code></pre></p> </li> <li> <p><code>router.BEFORE(url: str, handler: func, subdomain: str)</code> -&gt; Same as after hook above - but runs before all matching routes.</p> </li> <li> <p><code>router.CONNECT(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a <code>CONNECT</code> http     request to the provided <code>url</code> is received.</p> </li> <li> <p><code>router.DELETE(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a <code>DELETE</code> http     request to the provided <code>url</code> is received.</p> </li> <li> <p><code>router.GET(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a <code>GET</code> http     request to the provided <code>url</code> is received.</p> </li> <li> <p><code>router.HEAD(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a <code>HEAD</code> http     request to the provided <code>url</code> is received.</p> </li> <li> <p><code>router.HTTP(url: str, handler: func, subdomain: str)</code> -&gt; Registers the same <code>handler</code> <code>func: Callable[[Request, Response, Context], None]</code>      to be called for <code>ALL</code> http request methods i.e. GET, PUT, POST, PUT, PATCH etc. instead of doing it individually.     <pre><code># this is one line\nrouter.HTTP('/', lambda req, res, ctx: res.renders('index.html'))\n\n# but is the same as this\nrouter.CONNECT('/', lambda req, res, ctx: res.renders('index.html'))\nrouter.DELETE('/', lambda req, res, ctx: res.renders('index.html'))\nrouter.GET('/', lambda req, res, ctx: res.renders('index.html'))\nrouter.HEAD('/', lambda req, res, ctx: res.renders('index.html'))\nrouter.OPTIONS('/', lambda req, res, ctx: res.renders('index.html'))\nrouter.PATCH('/', lambda req, res, ctx: res.renders('index.html'))\nrouter.POST('/', lambda req, res, ctx: res.renders('index.html'))\nrouter.PUT('/', lambda req, res, ctx: res.renders('index.html'))\nrouter.TRACE('/', lambda req, res, ctx: res.renders('index.html'))\n</code></pre></p> </li> <li> <p><code>router.OPTIONS(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a <code>OPTIONS</code> http     request to the provided <code>url</code> is received.</p> </li> <li> <p><code>router.PATCH(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a <code>PATCH</code> http     request to the provided <code>url</code> is received.</p> </li> <li> <p><code>router.POST(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a <code>POST</code> http     request to the provided <code>url</code> is received.</p> </li> <li> <p><code>router.PUT(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a <code>PUT</code> http     request to the provided <code>url</code> is received.</p> </li> <li> <p><code>router.TRACE(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a <code>TRACE</code> http     request to the provided <code>url</code> is received.</p> </li> </ul>"},{"location":"request/","title":"Minute 4: The Request \ud83d\udce8","text":"<p>You've built the airport (Router), but here comes the plane. The <code>Request</code> object contains everything the client sent you, pre-parsed and ready to fly.</p> <p>The signature of every handler in Heaven is:</p> <pre><code>async def handler(req, res, ctx):\n    ...\n</code></pre> <p>Let's dissect <code>req</code>.</p>"},{"location":"request/#the-basics","title":"The Basics","text":"<ul> <li><code>req.body</code>: (bytes) The raw body.</li> <li><code>req.method</code>: (str) <code>GET</code>, <code>POST</code>, etc.</li> <li><code>req.url</code>: (str) The full path (e.g., <code>/users/1?active=true</code>).</li> <li><code>req.route</code>: (str) The route template (e.g., <code>/users/:id</code>).</li> </ul>"},{"location":"request/#data-access","title":"Data Access","text":""},{"location":"request/#url-parameters-reqparams","title":"URL Parameters (<code>req.params</code>)","text":"<p>When you define a route like <code>/users/:id:int</code>, Heaven parses it automatically.</p> <pre><code># Route: app.GET('/users/:id:int')\n# URL: /users/42\nid = req.params.get('id')\nassert isinstance(id, int)\n</code></pre> <p>[!NOTE] Supported types: <code>:int</code>, <code>:float</code>, <code>:bool</code>, <code>:uuid</code>, <code>:date</code>, <code>:datetime</code>, <code>:str</code> (default).</p>"},{"location":"request/#query-strings-reqqueries","title":"Query Strings (<code>req.queries</code>)","text":"<p>Query parameters can also be typed in the route definition!</p> <pre><code># Route: app.GET('/search?limit:int&amp;sort:str')\n# URL: /search?limit=10&amp;sort=asc\n\nlimit = req.queries.get('limit') # 10 (int)\nsort = req.queries.get('sort') # 'asc' (str)\n</code></pre>"},{"location":"request/#json-bodies-reqdata","title":"JSON Bodies (<code>req.data</code>)","text":"<p>If you use Minute 7: Schema &amp; Docs, Heaven auto-validates the body and puts the result here.</p> <pre><code># Route registered with `expects=UserSchema`\nuser = req.data\nprint(user.name)\n</code></pre>"},{"location":"request/#forms-reqform","title":"Forms (<code>req.form</code>)","text":"<p>Access <code>application/x-www-form-urlencoded</code> or <code>multipart/form-data</code> uploads.</p> <pre><code>form = req.form\nusername = form.get('username')\npassword = form.get('password')\nfile = form.get('avatar') # For file uploads\n</code></pre>"},{"location":"request/#metadata","title":"Metadata","text":"<ul> <li><code>req.headers</code>: (dict) Lowercase header dictionary.</li> <li><code>req.cookies</code>: (dict) Client cookies.</li> <li><code>req.ip</code>: (Lookup) <code>req.ip.address</code> and <code>req.ip.port</code>.</li> <li><code>req.subdomain</code>: (str) The subdomain (e.g., <code>'api'</code> or <code>'www'</code>).</li> </ul> <p>Next: You've heard them. Now answer them. On to Minute 5: The Response.</p>"},{"location":"response/","title":"Minute 5: The Response \ud83d\udde3\ufe0f","text":"<p>You have listened. Now you must speak. The <code>Response</code> object gives you the tools to reply with JSON, HTML, Files, or even silence.</p> <p>The handler signature:</p> <pre><code>async def handler(req, res, ctx):\n    ...\n</code></pre>"},{"location":"response/#the-basics","title":"The Basics","text":"<ul> <li><code>res.status</code>: (int) The HTTP status code. Defaults to <code>200</code>.</li> <li><code>res.body</code>: (bytes|str|dict|list) The content.</li> </ul> <p>Wait, <code>dict</code>? Yes. If you register a schema, Heaven handles the encoding. If not, it assumes bytes/str.</p> <pre><code>res.body = \"Hello World\" # Text\nres.body = b\"Hello World\" # Bytes\n</code></pre>"},{"location":"response/#json","title":"JSON","text":"<pre><code># Manual JSON\nres.headers = 'Content-Type', 'application/json'\nres.body = json.dumps({'msg': 'hi'})\n\n# Heaven Helper (if using Schemas)\n# Just return the object matching the schema, Heaven does the rest.\nres.body = MyUserObject() \n</code></pre>"},{"location":"response/#headers","title":"Headers","text":"<p>Headers are simple key-value tuples. You can add as many as you like.</p> <pre><code># Add one\nres.headers = 'Content-Type', 'application/json'\n\n# Add another\nres.headers = 'X-Powered-By', 'Heaven'\n</code></pre>"},{"location":"response/#helpers","title":"Helpers","text":""},{"location":"response/#resredirectlocation","title":"<code>res.redirect(location)</code>","text":"<p>Send the user somewhere else.</p> <pre><code>res.redirect('https://google.com')\n</code></pre>"},{"location":"response/#resfilepath-filenamenone","title":"<code>res.file(path, filename=None)</code>","text":"<p>Stream a file from disk. Heaven handles the content-type automatically.</p> <pre><code># Serve inline (e.g. image)\nres.file('images/cat.jpg')\n\n# Force download\nres.file('reports/finance.pdf', filename='final_report.pdf')\n</code></pre>"},{"location":"response/#resabortbody","title":"<code>res.abort(body)</code>","text":"<p>Stop everything immediately. No subsequent hooks will run.</p> <pre><code>if user.is_banned:\n    res.status = 403\n    res.abort(\"Go away.\")\n</code></pre>"},{"location":"response/#resdeferfunc","title":"<code>res.defer(func)</code>","text":"<p>Run a task after the response has been sent to the user. This is great for tasks that shouldn't block the UI but aren't complex enough for a daemon.</p> <pre><code>async def send_email(app):\n    await email_service.send(...)\n\nres.defer(send_email)\nres.body = \"Email queued!\"\n</code></pre> <p>Next: How do we share data between the router, the request, and the response? On to Minute 6: The Context.</p>"},{"location":"router/","title":"Minute 3: The Router \ud83d\udee3\ufe0f","text":"<p>The Router is the nervous system of your Heaven application. It decides where requests go, what runs before them, and what runs after.</p>"},{"location":"router/#the-basic-contract","title":"The Basic Contract","text":"<pre><code>from heaven import App\n\napp = App() # An Alias for Router()\n\napp.GET ('/users', get_users)\napp.POST('/users', create_user)\napp.PUT ('/users/:id', update_user)\napp.DELETE('/users/:id', delete_user)\n</code></pre>"},{"location":"router/#the-string-paradigm-lazy-loading","title":"The String Paradigm (Lazy Loading)","text":"<p>Heaven supports a \"String Paradigm\" that allows you to pass the import path of your handler instead of the function itself.</p> <p>This works everywhere. Routes, Hooks, Lifecycle events, and Daemons.</p>"},{"location":"router/#1-routes","title":"1. Routes","text":"<pre><code># No need to import the function!\napp.GET('/users', 'controllers.user.get_all')\napp.POST('/users', 'controllers.user.create')\napp.PUT ('/users/:id', update_user)\napp.DELETE('/users/:id', delete_user)\n</code></pre>"},{"location":"router/#2-hooks-middleware","title":"2. Hooks (Middleware)","text":"<pre><code># Instead of: from middleware.auth import check_token\napp.BEFORE('/dashboard/*', 'middleware.auth.check_token')\n</code></pre>"},{"location":"router/#3-lifecycle","title":"3. Lifecycle","text":"<pre><code># Instead of: from db import connect\napp.ON('startup', 'db.connect')\n</code></pre>"},{"location":"router/#why-use-strings","title":"Why use strings?","text":"<ol> <li>Speed: Modules are imported only when the application starts or when routes are hit.</li> <li>Cleanliness: No more 50-line import blocks at the top of your file.</li> <li>Decoupling: Solves circular import headaches instantly.</li> </ol>"},{"location":"router/#subdomains","title":"Subdomains","text":"<p>Heaven handles subdomains natively. No \"Blueprint\" confusion.</p> <pre><code># Matches: https://api.mysite.com/users\napp.GET('/users', handler, subdomain='api')\n\n# Matches: https://admin.mysite.com/dashboard\napp.GET('/dashboard', handler, subdomain='admin')\n</code></pre>"},{"location":"router/#lifecycle-hooks-on-and-once","title":"Lifecycle Hooks: <code>ON</code> and <code>ONCE</code>","text":"<p>You have full control over the lifespan of your application.</p>"},{"location":"router/#oncefunc-or-onstartup-func","title":"<code>ONCE(func)</code> or <code>ON(STARTUP, func)</code>","text":"<p>Run code when the server starts. Perfect for database connections.</p> <pre><code>async def connect_db(app):\n    db = await Database.connect()\n    app.keep('db', db) # Persist it globally\n\napp.ONCE(connect_db)\n</code></pre>"},{"location":"router/#onshutdown-func","title":"<code>ON(SHUTDOWN, func)</code>","text":"<p>Clean up when the server stops.</p> <pre><code>async def cleanup(app):\n    db = app.peek('db')\n    await db.close()\n\napp.ON('shutdown', cleanup)\n</code></pre>"},{"location":"router/#middleware-hooks","title":"Middleware: Hooks","text":"<p>Heaven doesn't use the confusing \"middleware stack\" pattern. instead, it uses explicit <code>BEFORE</code> and <code>AFTER</code> hooks.</p>"},{"location":"router/#before","title":"<code>BEFORE</code>","text":"<p>Runs before a request hits the handler. If you abort here, the handler never runs.</p> <pre><code>async def check_auth(req, res, ctx):\n    if not req.headers.get('Authorization'):\n        res.abort('Unauthorized', status=401)\n\n# Protects /dashboard and everything under it\napp.BEFORE('/dashboard/*', check_auth)\n</code></pre>"},{"location":"router/#after","title":"<code>AFTER</code>","text":"<p>Runs after the handler returns. Good for logging or modifying headers.</p> <pre><code>async def add_server_header(req, res, ctx):\n    res.headers = 'Server', 'Heaven/0.6'\n\napp.AFTER('/*', add_server_header)\n</code></pre>"},{"location":"router/#daemons-background-tasks","title":"Daemons: Background Tasks \ud83d\udc7b","text":"<p>Heaven has a built-in process manager for background tasks. No Celery required.</p> <p>[!WARNING] Heaven is single-threaded. Never block the main loop with <code>time.sleep()</code>.</p>"},{"location":"router/#creating-a-daemon","title":"creating a Daemon","text":"<p>A daemon is a function that receives the <code>app</code> instance. If it returns a number <code>N</code>, it sleeps for <code>N</code> seconds and runs again.</p> <pre><code>async def heartbeat(app):\n    print(\"Lub-dub...\")\n    # Sleep 5 seconds, then repeat\n    return 5\n\napp.daemons = heartbeat\n</code></pre>"},{"location":"router/#mounting-applications","title":"Mounting Applications","text":"<p>You can mount entire other Heaven apps onto your main app. This is how you build modular monoliths.</p> <pre><code>from heaven import App\nfrom my_blog import blog_app\nfrom my_store import store_app\n\nmain = App()\n\n# Mounts blog_app at /blog\nmain.mount(blog_app) \n\n# Note: Mounting merges routes.\n# If blog_app had a route '/posts', it is now accessible on main at '/posts'\n# Wait, let's clarify alignment with minute 8.\n</code></pre> <p>[!TIP] Use <code>mount</code> to split your code into multiple files/modules, then simply combine them in <code>main.py</code>.</p> <p>Next: Now that we know how to route the request, let's learn how to read it. On to Minute 4: The Request.</p>"},{"location":"schema/","title":"Minute 7: Schema &amp; Documentation \ud83d\udcdc","text":"<p>Heaven doesn't just run your code; it understands it. By using schemas, you get instant validation, auto-generated documentation, and type safety, all powered by the incredibly fast <code>msgspec</code>.</p>"},{"location":"schema/#defining-schemas","title":"defining Schemas","text":"<p>A schema is just a class that describes your data.</p> <pre><code>from heaven import Schema # Alias for msgspec.Struct\n\nclass User(Schema):\n    id: int\n    name: str\n    email: str\n    is_admin: bool = False\n</code></pre>"},{"location":"schema/#the-schema-registry","title":"The Schema Registry","text":"<p>Instead of cluttering your handlers with decorators, Heaven uses a \"Sidecar\" pattern. You register schemas on the router's <code>schema</code> property.</p> <pre><code># 1. Register the metadata\napp.schema.POST('/users', \n    expects=User, \n    returns=User, \n    title=\"Create User\",\n    summary=\"Creates a new user in the system\"\n)\n\n# 2. Define the handler (clean!)\nasync def create_user(req, res, ctx):\n    user = req.data # Validated 'User' object\n    # database logic...\n    res.body = user # Heaven auto-converts this back to JSON\n\n# 3. Mount the handler\napp.POST('/users', create_user)\n</code></pre>"},{"location":"schema/#validation","title":"Validation","text":"<p>When you register an <code>expects</code> schema, Heaven automatically: 1.  Validates the incoming JSON body against the schema. 2.  Aborts with <code>422 Unprocessable Entity</code> if it's invalid (with a nice error message). 3.  Populates <code>req.data</code> with the validated object.</p>"},{"location":"schema/#auto-generated-docs-openapi","title":"Auto-Generated Docs (OpenAPI)","text":"<p>Heaven can generate a stunning interactive API reference website for you.</p> <pre><code># Mount the docs at /docs\napp.DOCS('/docs', title=\"My API\", version=\"1.0.0\")\n</code></pre> <p>Now visit <code>http://localhost:8000/docs</code> in your browser. You will see a beautiful Scalar UI where you can test your endpoints.</p>"},{"location":"schema/#advanced-subdomains","title":"Advanced: Subdomains","text":"<p>You can mount docs on a specific subdomain.</p> <pre><code>app.DOCS('/docs', subdomain='api')\n</code></pre>"},{"location":"schema/#advanced-output-protection","title":"Advanced: Output Protection","text":"<p>You can control how strict Heaven is about what you send back.</p> <pre><code>app.schema.GET('/users/:id', \n    returns=User,\n    protect=True,  # Strip fields not in User schema\n    strict=True    # Error 500 if a required field is missing\n)\n</code></pre> <ul> <li><code>protect=True</code>: Prevents data leaks. If your DB returns <code>password_hash</code> but your Schema doesn't have it, it won't be sent.</li> <li><code>partial=True</code>: Allows sending only a subset of fields (good for PATCH updates).</li> </ul> <p>Next: You have built it. But does it work? On to Minute 8: The Earth.</p>"},{"location":"snippets/","title":"Minute 9: Centralized Middleware &amp; Snippets","text":"<p>Heaven is extremely unopinionated, but it provides powerful tools for centralized control. This section shows how to use <code>.BEFORE</code> hooks for common tasks like Authentication and Data Validation.</p>"},{"location":"snippets/#centralized-authentication","title":"Centralized Authentication","text":"<p>Instead of littering your handlers with decorators, use <code>.BEFORE</code> to protect entire route trees at once.</p> <pre><code>from http import HTTPStatus\nfrom heaven import App, Request, Response, Context\n\napp = App()\n\n# 1. Define your protection logic\nasync def protect(req: Request, res: Response, ctx: Context):\n    token = req.headers.get('authorization')\n\n    # Use your preferred JWT or other validation scheme here\n    if not token or token != \"secret-token\":\n        # res.abort stops the request cycle immediately\n        res.abort('Unauthorized Access', status=HTTPStatus.UNAUTHORIZED)\n        return\n\n    # Keep the user in context for the actual handler\n    ctx.keep('user', {\"id\": 1, \"name\": \"Raymond\"})\n\n# 2. Register it globally or for specific route patterns\napp.BEFORE('/api/v1/*', protect)\n\n# 3. Your handler stays clean and focused\nasync def get_secure_data(req: Request, res: Response, ctx: Context):\n    user = ctx.user # Already populated by the hook\n    res.body = {\"data\": \"Top Secret\", \"for\": user['name']}\n\napp.GET('/api/v1/data', get_secure_data)\n</code></pre>"},{"location":"snippets/#centralized-data-validation","title":"Centralized Data Validation","text":"<p>You can also use <code>.BEFORE</code> to validate incoming data before it ever reaches your handler.</p> <pre><code>import json\nfrom heaven import App, Request, Response, Context\n\napp = App()\n\nasync def validate_json(req: Request, res: Response, ctx: Context):\n    try:\n        data = json.loads(req.body)\n        if \"email\" not in data:\n            raise ValueError(\"Email is required\")\n        ctx.keep('payload', data)\n    except Exception as e:\n        res.abort(f\"Invalid Data: {str(e)}\", status=400)\n\napp.BEFORE('/api/v1/login', validate_json)\n\nasync def login(req: Request, res: Response, ctx: Context):\n    payload = ctx.payload\n    print(f\"Logging in {payload['email']}\")\n    res.body = {\"status\": \"ok\"}\n\napp.GET('/api/v1/login', login)\n</code></pre> <p>[!TIP] Use <code>.BEFORE('*', handler)</code> to run a hook for every single request in your application (e.g., for logging or CORS).</p>"}]}