{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Heaven \u26a1","text":"<p>You are here because you want to build Python web applications without the boilerplate, the bloat, or the confusion.</p> <p>Heaven is the super-simple, extremely fast, web framework for purists. It doesn't use \"magic\" decorators to hide how things work. It gives you raw ASGI speed with a developer experience that allows for complete mastery in 10 minutes or less.</p>"},{"location":"#why-heaven","title":"Why Heaven?","text":"<p>If you are tired of: - FastAPI's complex dependency injection and verbose schemas. - Flask's aging internal architecture and global variables. - Django's massive boilerplate and rigid structure.</p> <p>...then you belong in Heaven.</p>"},{"location":"#your-10-minute-journey-to-mastery","title":"Your 10-Minute Journey to Mastery","text":"<p>We believe you should be able to read the source code of your framework. Heaven is small enough that you can.</p> <ul> <li>Minute 1: Quickstart - From Zero to Hello World.</li> <li>Minute 2: The Request - Understanding the incoming data.</li> <li>Minute 3: The Response - Sending data back to the world.</li> <li>Minute 4: The Context - Managing state across your app.</li> <li>Minute 5: The Router &amp; Daemons - Routing, Hooks, and Background Jobs.</li> <li>Minute 6: HTML &amp; Assets - Serving templates and static files.</li> <li>Minute 7: Drinking Coffee - You're almost a master.</li> <li>Minute 8: Application Mounting - Building modular, large-scale apps.</li> <li>Minute 9: Auth &amp; Validation - Protecting your endpoints with <code>.BEFORE</code>.</li> <li>Minute 10: The Finish Line - You are now a Heaven Master.</li> </ul>"},{"location":"#get-started-now","title":"Get Started Now","text":"<pre><code>$ pip install heaven\n</code></pre> <pre><code>from heaven import App\n\napp = App()\n\napp.GET('/', lambda req, res, ctx: res.renders('index.html'))\n\n# Run with any ASGI server\n# $ uvicorn app:app --port 5000 --reload\n</code></pre>"},{"location":"api/","title":"Heaven API Reference \ud83d\udcd6","text":"<p>A comprehensive guide to every method, property, and constant in the Heaven framework.</p>"},{"location":"api/#app-router","title":"App / Router","text":"<p>The central orchestrator of your application.</p>"},{"location":"api/#app-routerprotect_outputtrue","title":"<code>App()</code> / <code>Router(protect_output=True, ...)</code>","text":"<p>Initialize the framework.  - <code>protect_output</code>: (Default <code>True</code>) Enables <code>msgspec</code> validation/projection. - <code>fail_on_output</code>: (Default <code>False</code>) Determines if individual validation errors should crash the request or just log a warning.</p>"},{"location":"api/#routing-methods","title":"Routing Methods","text":"<p>All methods follow the signature: <code>(url: str, handler: Callable, subdomain: str = DEFAULT)</code> - <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>PATCH</code>, <code>HEAD</code>, <code>OPTIONS</code>, <code>CONNECT</code>, <code>TRACE</code> - <code>HTTP(url, handler)</code>: Registers all the above methods at once. - <code>SOCKET(url, handler)</code>: Registers a WebSocket handler.</p>"},{"location":"api/#hooks-lifecycle","title":"Hooks &amp; Lifecycle","text":"<ul> <li><code>BEFORE(url, handler)</code>: Runs before matching routes.</li> <li><code>AFTER(url, handler)</code>: Runs after matching routes.</li> <li><code>ON(event, handler)</code>: Lifecycle hooks for <code>STARTUP</code> and <code>SHUTDOWN</code>.</li> </ul>"},{"location":"api/#utilities","title":"Utilities","text":"<ul> <li><code>mount(url, other_router)</code>: Nest applications.</li> <li><code>daemon(coroutine)</code>: Register background tasks that run with the server lifecycle.</li> <li><code>listen(host, port)</code>: shortcut for <code>uvicorn.run</code>.</li> <li><code>openapi()</code>: Generates the OpenAPI spec dictionary.</li> <li><code>DOCS(url)</code>: Serves the Swagger/OpenAPI UI.</li> </ul>"},{"location":"api/#request-req","title":"Request (<code>req</code>)","text":"<p>The object representing an incoming HTTP or WebSocket request.</p> <ul> <li><code>req.app</code>: Access the parent <code>Router</code> instance.</li> <li><code>req.method</code>: <code>str</code> (GET, POST, etc.)</li> <li><code>req.url</code>: <code>str</code> (Relative path)</li> <li><code>req.headers</code>: <code>dict</code>-like access to headers.</li> <li><code>req.cookies</code>: Parsed <code>dict</code> of cookies.</li> <li><code>req.params</code>: <code>dict</code> of URL parameters (e.g., <code>:id</code>).</li> <li><code>req.queries</code>: <code>dict</code> of query string parameters.</li> <li><code>req.json</code>: Body decoded via <code>msgspec</code>.</li> <li><code>req.data</code>: Validated/Structured body data (if <code>Schema</code> is used).</li> <li><code>req.form</code>: Parsed <code>multipart</code> or <code>urlencoded</code> data.</li> <li><code>req.ip</code>: Client IP address info.</li> <li><code>req.subdomain</code>: Current subdomain string.</li> </ul>"},{"location":"api/#response-res","title":"Response (<code>res</code>)","text":"<p>Used to send data back to the client. All methods return <code>self</code> for chaining.</p> <ul> <li><code>res.status = 200</code>: Set HTTP status code.</li> <li><code>res.body = \"data\"</code>: Set the response body.</li> <li><code>res.json()</code>: Returns/sets body as JSON.</li> <li><code>res.text()</code>: Returns/sets body as text.</li> <li><code>res.header(key, val)</code>: Set a header.</li> <li><code>res.cookie(key, val, ...)</code>: Set a cookie.</li> <li><code>res.renders(template, **data)</code>: Render a Jinja2 template.</li> <li><code>res.file(path)</code>: Serve a static file.</li> <li><code>res.stream(gen, sse=False)</code>: Stream an async generator (with optional SSE formatting).</li> <li><code>res.abort(body=None)</code>: Stop execution and return immediately.</li> </ul>"},{"location":"api/#context-ctx","title":"Context (<code>ctx</code>)","text":"<p>Shared state container for the duration of a request.</p> <ul> <li><code>ctx.keep(key, val)</code>: Store a value.</li> <li><code>ctx.peek(key)</code>: Retrieve a value.</li> <li><code>ctx.unkeep(key)</code>: Remove and return a value.</li> <li><code>ctx.something</code>: Property-style access to kept values.</li> </ul>"},{"location":"api/#earth","title":"Earth","text":"<p>The integration testing engine. Access via <code>router.earth</code>.</p> <ul> <li><code>earth.GET(url, ...)</code> / <code>earth.POST(...)</code>: Simulate requests.</li> <li><code>earth.upload(url, files=...)</code>: Multipart upload helper.</li> <li><code>earth.SOCKET(url)</code>: WebSocket simulation client.</li> <li><code>earth.test(track_session=True)</code>: Context manager for full lifecycle + session tests.</li> </ul>"},{"location":"coffee/","title":"Sip some coffee \u2615\ufe0f","text":"<p>You've made it through the core of Heaven! </p> <p>By now, you should feel comfortable with: - Handling Requests - Sending Responses - Managing State via Context - Mounting Apps &amp; Using Daemons</p> <p>Take a moment to enjoy the simplicity. When you're ready, we'll dive into the advanced features and the Full API Reference.</p>"},{"location":"congrats/","title":"Min. 10&colon; Congratulate Yourself","text":""},{"location":"congrats/#how-quick-was-that","title":"How quick was that?","text":"<p>Did you get here in 10 minutes? If you did - congratulations. If not, congats all the same. We read at different speeds and that variety is said to be the spice of life.</p> <p>If you need more than 10 minutes: there is an API reference and large collection of code examples as optional reading material in the next sections.</p> <p>If not, pick your farewell: May the force be with you or Live long and prosper</p>"},{"location":"context/","title":"Min. 4&colon; Context of Heaven","text":"<p><code>View Source Code:</code> <code>Open on GitHub</code></p>"},{"location":"context/#minute-4","title":"Minute 4","text":""},{"location":"context/#object-3-context","title":"Object #3. Context","text":"<p>All handlers receive this as the third argument i.e. <code>...(..., ..., c: Context)</code> to help with preserving state across     multiple handlers (i.e. from when a request is received to when a response is sent).</p> <ul> <li><code>c.keep(alias: str, value: any)</code> -&gt; Save something that can be retrieved via Python descriptor semantics. i.e. <code>c.alias</code> will return the kept value.</li> </ul> <pre><code>from functools import wraps\n\n\ndef example(func):\n    @wraps(func)\n    async def wrapper(req, res, ctx):\n        ctx.keep('user_id', 1986)\n        func(req, res, ctx)\n    return wrapper\n\n\n@example\ndef get_user(req, res, ctx):\n    assert ctx.user_id == 1986\n</code></pre> <p> </p> <p>Next: Application</p>"},{"location":"examples/","title":"Optional&colon; Library of Examples","text":""},{"location":"examples/#how-tos-and-code-examples","title":"How-To's and Code Examples","text":"<p>Heaven is currently being used in production by a few customer facing web products and to power high performance microservices. Below are some of the observations and collated practices that might help provide some guidance on code patterns possible in heaven.</p>"},{"location":"examples/#decorator-functions","title":"Decorator Functions","text":"<p>Useful for intercepting and performing actions before the decorated function is invoked i.e. <code>authentication</code>, <code>dependency injection</code>, or <code>authorization</code> amongst other possibilities.</p> <p>This example demonstrates one of the ways Authentication might be implemented with the <code>pyjwt</code> library. <pre><code>from asyncpg import Pool\nfrom jwt import decode\n\n\ndef protected(func):\n    \"\"\"Authentication\"\"\"\n    @wraps(func)\n    def delegate(r: Request, w: Response, c: Context):\n        token = r.headers.get('authorization')\n        secret_key = r.app.CONFIG('SECRET_KEY')\n\n        try: credentials = decode(token, secret_key, algorithm='HS256')\n        except: return w.status = status.UNAUTHORIZED\n        else: c.keep('current_user') = credentials.get('id')\n\n        return await func(r, w, c)\n    return delegate\n\n\ndef private(resource: str):\n    \"\"\"RBAC Authorization, heaven makes it easy to also use ABAC\"\"\"\n    def wrapper(func):\n        @wraps(func)\n        def delegate(r: Request, w: Response, c: Context):\n            dbpool: Pool = r.app.peek('dbpool')\n            action = r.method.lower()\n            with dbpool.acquire() as sqld:\n                try: roles = await sqld.fetchval(\"\"\"\n                    SELECT roles\n                    FROM privileges\n                    WHERE user = $1 AND action = $2 AND resource = $3\n                \"\"\", c.current_user, action, resource)\n                except:\n                    w.status = HTTPStatus.SERVICE_UNAVAILABLE\n                    w.body = dumps({'message': 'please try again later'})\n            if action in roles: return await func(r, w, c)\n\n            w.status = HTTPStatus.UNAUTHORIZED\n            w.body = dumps({'message': 'insufficient privileges'})\n        return delegate\n    return wrapper\n</code></pre></p>"},{"location":"examples/#schema-validation-documentation","title":"Schema Validation &amp; Documentation","text":"<p>Use <code>router.schema</code> to define your API contracts and <code>router.DOCS</code> to generate interactive documentation.</p> <pre><code>from heaven import App, Schema\n\napp = App()\n\nclass User(Schema):\n    id: int\n    email: str\n    role: str = \"guest\"\n\n# Define your handler\nasync def create_user(req, res, ctx):\n    user = req.data # Validated User struct\n    print(f\"Creating user: {user.email}\")\n    res.body = {\"status\": \"created\", \"id\": 123}\n\n# 1. Register endpoint metadata\napp.schema.POST(\n    '/v1/users', \n    expects=User, \n    returns=dict, \n    summary=\"Create a new user\",\n    description=\"Creates a guest user by default if role is not provided.\"\n)\n\n# 2. Register handler\napp.POST('/v1/users', create_user)\n\n# 3. Enable Scalar Documentation\napp.DOCS('/api/docs', title=\"User Service API\")\n</code></pre> <p>The above setup provides: - Automatic 422 errors for invalid JSON. - Static typing in your handler via <code>req.data</code>. - Interactive docs at <code>/api/docs</code>.</p>"},{"location":"html/","title":"Minute 6: Rendering HTML","text":"<p>Heaven uses Jinja as its templating engine. This however does not stop you from rolling your own preferred template engine.</p> <p>You can render html templates in <code>asynchronous</code> or <code>asyncrhonous=False</code> modes.</p> <pre><code>from routerling import Application\n\napplication = Application()\n\n# application.TEMPLATES('my/templates/folder', asynchronous=False)\napplication.TEMPLATES('my/templates/folder')  # asynchronous=True\n\n\nasync def index(req, res, ctx):\n    ctx.keep('message', 'Hello world!')\n    await res.render('index.html', req=req, my_name='Santa')\n\n\napplication.GET('/', index)\n</code></pre> <p>In your <code>index.html</code> file <code>Note:</code> heaven will inject <code>ctx</code> automatically: <pre><code>&lt;h1&gt;{{ ctx.message }}&lt;/h1&gt;&lt;!-- injected by heaven automatically --&gt;\n&lt;p&gt;{{ my_name }}&lt;/p&gt;&lt;!-- you injected this manually --&gt;\n</code></pre></p> <p>You can also pass additional arguments <code>response.render('', *args)</code> the rendered template as is.</p> <p>For more see tutorial - how to use Jinja.</p>"},{"location":"mount/","title":"Mounting Routers","text":"<p>Heaven allows for applications to be mounted on top of each other. See example below</p> <p>First let's create our backend api as a heaven application/router in a file called:</p> <p><code>api.py</code> <pre><code>from heaven import Router\n\napi = Router()\napi.GET('/v1/customers', lambda req, res, ctx:...)\n</code></pre></p> <p>Next we create our frontend renderer as another heaven application/router:</p> <p><code>pages.py</code> <pre><code>from heaven import Router\n\npages = Router()\n\n# folder where your templates are stored\npages.TEMPLATES('templates', asynchronous=False)\npages.ASSETS('assets')\n\n\npages.GET('/', lambda req, res, ctx: res.renders('index.html'))\n</code></pre></p> <p>Finally we create our main heaven application that will configure database connections and mount the <code>backend app</code> and <code>frontend app</code> on itself as mounted children:</p> <p><code>app.py</code> <pre><code>from heaven import Application\n\napp = Application()\n\napp.mount(api, isolated=True)\napp.mount(pages, isolated=False)\n</code></pre> isolation=False means no middlewares, config, or state is shared between router instances - only routes will be mounted.</p>"},{"location":"quickstart/","title":"Minute 1","text":"<p>We are assuming you have installed heaven via <code>pip install heaven</code>. If no, then go ahead and install it; If you have, then the clock is ticking so let's dive in.</p>"},{"location":"quickstart/#1-create-a-handler-function","title":"1. Create a handler function","text":"<p>In a file of your choosing: i.e. <code>controllers.py</code> or <code>src/controllers/customers.py</code> <pre><code>import json\nfrom http import HTTPStatus\n\nfrom heaven import Request, Response, Context\n\nasync def get_one_customer(req: Request, res: Response, ctx: Context):\n    id = req.params.get('id')\n    res.status = HTTPStatus.CREATED\n    res.body = json.dumps({\"message\": f\"heaven is easy for customer {id}\"})\n</code></pre></p> <p>As you can see above - your handler functions can also be async, and must accept 3 arguments that will be injected by heaven. We'll get to them in Minute 2, Minute 3 and Minute 4.</p>"},{"location":"quickstart/#2-connect-your-handler-to-the-heaven-application","title":"2. Connect your handler to the heaven application","text":"<p>Heaven wants your application and development time to be fast so you don't need to import handler functions, just tell your <code>router</code>, <code>application</code> where your handler function lives and heaven will load it for you.</p> <p>Of course you can still import it explicitly if you are an extreme purist ;-)</p> <pre><code>from heaven import Router\n\n# create the application\nrouter = Router()\n\n# a string path to the python module and function name is enough\n# as you can imagine this saves you time with manual imports\n# if you have a lot of handlers in your project\nrouter.GET('/v1/customers/:id', 'controllers.customers.get_one_customer')\n</code></pre> <p>All HTTP methods i.e. <code>GET</code>, <code>POST</code> etc. are all supported</p>"},{"location":"quickstart/#3-run-with-gunicorn-or-uvicorn","title":"3. Run With Gunicorn or Uvicorn","text":"<pre><code># assuming your my_app.py is in a file called app.py\nuvicorn my_app:router  --reload --port 9000\n\n# or\n\ngunicorn -w 4 -k uvicorn.workers.UvicornWorker application:router\n</code></pre> <p>Next: Requests to Heaven</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#alphabetical-list-of-all-heaven-apis","title":"Alphabetical List of All Heaven APIs","text":"<ul> <li> <p><code>constants.DEFAULT</code> -&gt; A <code>str</code> constant helpful to preven you from typing <code>'www'</code> everywhere in your code.</p> </li> <li> <p><code>constants.WILDCARD</code> -&gt; A <code>str</code> constant helpful to prevent you from typing <code>'*'</code> everywhere in your code.</p> </li> <li> <p><code>context.keep(key: str, value: any)</code> -&gt; This is how values are kept/stored in the context API for use across http requests.     see decorator code snippet for example on its usage</p> </li> <li> <p><code>form.Form</code> -&gt; Tiny wrapper around a dict returned from <code>req.FORM</code> when content-type of request is of type <code>multitype/form-data</code> or     <code>application/x-www-form-urlencoded</code> <pre><code>from heaven.form import Form\n\nHEADERS = ['multitype/form-data', 'application/x-www-form-urlencoded']\n\nasync def example(req, res, ctx):\n    if(req.headers.get('content-type') in HEADERS):\n        isinstance(req.form, Form)  # --&gt; True\n        print(form.email)\n        print(form.password)\n    else:\n        assert req.form is None  # --&gt; True\n</code></pre></p> </li> <li> <p><code>router.AFTER(url: str, handler: func, subdomain: str)</code> -&gt; This is called a hook - a function that is hooked to run after all matching routes.     <pre><code>message = 'I will run after all /v1/* routes'\nrouter.AFTER('/v1/*', lambda req, res, ctx: print(message))\n\n# will run after\nrouter.GET('/v1/customers', ...)\nrouter.POST('/v1/leads', ...)\n\n# but not after\nrouter.GET('/v2/customers')\n</code></pre></p> </li> <li> <p><code>router.BEFORE(url: str, handler: func, subdomain: str)</code> -&gt; Same as after hook above - but runs before all matching routes.</p> </li> <li> <p><code>router.CONNECT(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a <code>CONNECT</code> http     request to the provided <code>url</code> is received.</p> </li> <li> <p><code>router.DELETE(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a <code>DELETE</code> http     request to the provided <code>url</code> is received.</p> </li> <li> <p><code>router.GET(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a <code>GET</code> http     request to the provided <code>url</code> is received.</p> </li> <li> <p><code>router.HEAD(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a <code>HEAD</code> http     request to the provided <code>url</code> is received.</p> </li> <li> <p><code>router.HTTP(url: str, handler: func, subdomain: str)</code> -&gt; Registers the same <code>handler</code> <code>func: Callable[[Request, Response, Context], None]</code>      to be called for <code>ALL</code> http request methods i.e. GET, PUT, POST, PUT, PATCH etc. instead of doing it individually.     <pre><code># this is one line\nrouter.HTTP('/', lambda req, res, ctx: res.renders('index.html'))\n\n# but is the same as this\nrouter.CONNECT('/', lambda req, res, ctx: res.renders('index.html'))\nrouter.DELETE('/', lambda req, res, ctx: res.renders('index.html'))\nrouter.GET('/', lambda req, res, ctx: res.renders('index.html'))\nrouter.HEAD('/', lambda req, res, ctx: res.renders('index.html'))\nrouter.OPTIONS('/', lambda req, res, ctx: res.renders('index.html'))\nrouter.PATCH('/', lambda req, res, ctx: res.renders('index.html'))\nrouter.POST('/', lambda req, res, ctx: res.renders('index.html'))\nrouter.PUT('/', lambda req, res, ctx: res.renders('index.html'))\nrouter.TRACE('/', lambda req, res, ctx: res.renders('index.html'))\n</code></pre></p> </li> <li> <p><code>router.OPTIONS(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a <code>OPTIONS</code> http     request to the provided <code>url</code> is received.</p> </li> <li> <p><code>router.PATCH(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a <code>PATCH</code> http     request to the provided <code>url</code> is received.</p> </li> <li> <p><code>router.POST(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a <code>POST</code> http     request to the provided <code>url</code> is received.</p> </li> <li> <p><code>router.PUT(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a <code>PUT</code> http     request to the provided <code>url</code> is received.</p> </li> <li> <p><code>router.TRACE(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a <code>TRACE</code> http     request to the provided <code>url</code> is received.</p> </li> </ul>"},{"location":"request/","title":"Min. 2&colon; Request to Heaven","text":"<p><code>View Source Code:</code> <code>Open on GitHub</code></p>"},{"location":"request/#minute-2","title":"Minute 2","text":"<p>A promise is a promise. So it's time to tell you about heaven's objects. Don't fret - there are only 4 of them.</p>"},{"location":"request/#object-1-request","title":"Object #1: Request","text":"<p>All handlers will receive this as their first argument i.e. <code>...(req: Request, ..., ...)</code> - and all Request objects come with the following helper properties (bag of goodies).</p> <ul> <li> <p><code>req.app: Router</code> -&gt; An instance of the base heaven application     <pre><code>from heaven import App\n\napp = App()\n\n# For instance if this app could talk it might tell you:\n# Hello my name is `your-app` - I am a Python web application\n# I spend my time serving web requests and \n# when I am free - I spend my time dreaming of becoming a chess engine\napp_id = id(app)\n\n\nasync def handler(req, res, ctx):\n    # Hello again in all your handler functions\n    # mounted on `app` - Your friendly neigborhood\n    # `your-app` is present as well\n    assert id(req.app) == app_id\n</code></pre></p> </li> <li> <p><code>req.body: bytes</code> -&gt; The body sent along with the request     <pre><code>...\nfrom ujson import loads\n\n\n# for instance to process a post json request\ndef handler(req: Request, res: Response, ctx: Context):\n    body = loads(req.body)\n...\n</code></pre></p> </li> <li> <p><code>req.data: Schema</code> -&gt; If a schema was registered for the route via <code>router.schema</code>, this property      will hold the validated <code>Schema</code> instance. If validation failed, Heaven will have already aborted      with a <code>422 Unprocessable Entity</code>.     <pre><code>async def create_user(req, res, ctx):\n    user = req.data # instance of your Schema\n    print(user.id)\n</code></pre></p> </li> <li> <p><code>req.cookies: dict</code> -&gt; All the cookies sent with request [case sensitive - case preserved] <pre><code>...\n\ndef handler(req, res, ctx):\n    # cookies are case sensitive\n    token = req.cookies.get('Authorization')\n    different_token = req.cookies.get('authorization')  \n...\n</code></pre></p> </li> <li> <p><code>req.form: Form</code> -&gt; If content-type is <code>multipart/form-data</code> or <code>application/x-www-form-urlencoded</code>, this will return a <code>Form</code> object.     <pre><code>...\n\ndef create_lead(req, res, ctx):\n    form = req.form\n    print(form.name)\n    print(form.password)\n...\n</code></pre></p> </li> <li> <p><code>req.headers: dict</code> -&gt; All the headers sent with request [keys in lowercase] i..e <code>req.headers.get('content-type')</code> <pre><code>...\n\ndef handler(req: Request, res: Response, ctx: Context):\n    # if a browser sends you a request with Content-Type application/json\n    # then this will assert True\n    assert req.headers.get('content-type') == 'application/json'\n...\n</code></pre></p> </li> <li> <p><code>req.host: str</code> -&gt; The <code>Host</code> header value.</p> </li> <li> <p><code>req.ip: Lookup</code> -&gt; Client address and port information.     <pre><code>def handler(req, res, ctx):\n    print(req.ip.address)\n    print(req.ip.port)\n</code></pre></p> </li> <li> <p><code>req.method: str</code> -&gt; <code>GET</code>, <code>POST</code>, <code>DELETE</code>? What method type is the http request</p> </li> <li> <p><code>req.mounted: app</code> -&gt; The mounted router if this request handler is from a mounted router.     <pre><code>from router import Router, App\n\nrouter_1 = Router()\nrouter_1.GET('/', lambda req, res, ctx:...)\n\napp = App()\napp.mount(router_1) # all routes defined on router_1 will be mounted to app\n...\n</code></pre></p> <p>Info</p> <p>Mounted <code>apps</code> or <code>routers</code> can be useful if you have different configurations on child routers and want to access them separately. e.g. different routers can use different database connections i.e. mongodb and postgres</p> </li> <li> <p><code>req.params: dict</code> -&gt; URL params i.e. <code>/customers/:param1</code> defined in as your part of your route(s) parsed into a     dictionary <pre><code># for the following routes\napp.GET('/customers/:id:int/messages/:message_id')\n\ndef get_customer_messag_by_id(req: Request, res: Response, ctx: Context):\n    '''when a user visits /customers/1/messages/33'''\n    print(req.params)  # -&gt; {'id': 1, 'message_id': '33'}\n</code></pre></p> <p>From v0.4.2</p> <p>In case you missed it - you can coerce url parameters into the following python types</p> <ul> <li><code>/v1/customers/:param:int</code> -&gt; <code>int</code></li> <li><code>/products/:id:str</code> -&gt; <code>str</code> - this is the default so the <code>:str</code> can be omitted</li> </ul> </li> <li> <p><code>req.queries: dict</code> -&gt; Query string key value pairs i.e. <code>?limit=45&amp;asc=name</code> parsed into a dictionary</p> <p>From v0.4.2</p> <p>You can also coerce query parameters if present in the request url to the following python types</p> <ul> <li><code>?query1:datetime</code> -&gt; <code>datetime.datetime</code></li> <li><code>?query5:date</code> -&gt; <code>datetime.date</code></li> <li><code>?query2:int</code> -&gt; <code>int</code></li> <li><code>?query3:str</code> -&gt; <code>str</code></li> <li><code>?query4:float</code> -&gt; <code>float</code></li> <li><code>?query5:uuid</code> -&gt; <code>uuid.UUID</code></li> <li><code>?query6:bool</code> -&gt; <code>bool</code> v0.4.3 </li> </ul> <p>To do this provide a suffix in your URL <code>route</code> declaration, and don't worry - your URL will work   the same as when it is not there. The only difference will be that if the users of your app do provide   query values then Heaven will attempt to parse them into the correct python data types.   <pre><code>...\n\n# for instance for the following route\napp.GET('/customers/:id?limit:int&amp;paginate:int&amp;page:str')\n\n# when a user visits /customers/1?limit=44&amp;page=3&amp;pagination=100\ndef get_customer_messag_by_id(req: Request, res: Response, ctx: Context):\n    print(req.queries)  # -&gt; {'limit': 44, 'pagination': 100, 'page': '3'}\n\n...\n</code></pre></p> </li> <li> <p><code>req.querystring: str</code> -&gt; The part after the <code>?</code> i.e. <code>example.com</code>?age=34 parsed as a string     without further processing or key value extraction performed.</p> </li> <li> <p><code>req.scheme: dict</code> -&gt; <code>http</code> or <code>https</code> i.e. what protocol was sent to your server on the current request using.</p> </li> <li> <p><code>req.route: str</code> -&gt; The raw route template that matched this request (e.g., <code>/customers/:id</code>).     <pre><code>def handler(req, res, ctx):\n    # Even if user visits /customers/23\n    # req.route will be /customers/:id\n    assert req.route == '/customers/:id'\n</code></pre></p> </li> <li> <p><code>req.subdomain: str</code> -&gt; If request was made to a subdomain i.e. www<code>.example.org</code> or api<code>.example.org</code>     then this holds the subdomain value e.g. <code>www</code> and <code>api</code>.</p> </li> <li> <p><code>req.url: str</code> -&gt; The actual url sent by the client (e.g., <code>/customers/23</code>).     <pre><code>...\n\ndef handler(req: Request, res: Response, ctx: Context):\n    # if handler is attached to app at app.GET('/v1/users/:id', ...)\n    # if a visitor types /v1/users/3 into their browser\n    # to visit your app then the following will be true\n    assert req.url ==  '/v1/users/3'\n...\n</code></pre></p> </li> </ul> <p> </p> <p>Next: Response from Heaven</p>"},{"location":"response/","title":"Min. 3&colon; Response from Heaven","text":"<p><code>heaven.response.Response:</code> <code>Open on GitHub</code></p>"},{"location":"response/#minute-3","title":"Minute 3","text":""},{"location":"response/#object-2-response","title":"Object #2. Response","text":"<p>All handlers receive this as the second argument i.e. <code>...(..., res: Response, ...)</code> with the following <code>properties</code> &amp; <code>methods</code> to help with responding to http requests.</p> <ul> <li> <p><code>res.body: any = 'hello'</code> -&gt; Sets the body that will be sent back with the response object.</p> </li> <li> <p><code>res.defer(func: Callable)</code> -&gt; Registers a function to be called after the         response is sent to the client. Callable must accept a single parameter of <code>type: Router | Application</code> <pre><code>def send_sms_after_request(router: Router):\n        twilio = router.peek('twilio')\n        twilio.messages.create(to='+123456', from='+123456', body='Hi!')\n\n\nasync def create_order(req, res, ctx):\n        res.defer = send_sms_after_request\n        res.defer = lambda r: print('I will be called too...')\n        res.status = 202\n</code></pre></p> </li> <li> <p><code>res.headers: tuple[2] | list[2]</code> -&gt; How headers are set i.e.         <pre><code>res.headers = 'Set-Cookie', 'Token=12345; Max-Age=8700; Secure; HttpOnly'\n</code></pre></p> </li> <li> <p><code>res.status: int</code> -&gt; HTTP status code to be sent back with the response</p> </li> <li> <p><code>res.render(html: str, **context): Coroutine[str]</code> -&gt; Asynchronous function to help with         rendering html. See rendering html tutorial</p> </li> <li> <p><code>res.redirect(location: str)</code> -&gt; This does this for you behind the scenes.         <pre><code>res.status = HTTPStatus.TEMPORARY_REDIRECT\nres.headers = 'Location', '/location'\n</code></pre>         Browsers will redirect upon receipt of the header and http status above.</p> </li> <li> <p><code>res.file(path: str, filename: str = None)</code> -&gt; Serve a file from the filesystem with automatic          MIME type detection and streaming support. If <code>filename</code> is provided, it sets the <code>Content-Disposition</code>          to <code>attachment</code>, otherwise it defaults to <code>inline</code>.         <pre><code>async def download_report(req, res, ctx):\n    res.file('/path/to/report.pdf', filename='monthly_report.pdf')\n</code></pre></p> </li> <li> <p><code>res.abort(payload: any)</code> -&gt; If this is called then all <code>PRE</code> and <code>POST</code> hooks will be aborted</p> </li> </ul> <p>Here is a sample request handler function that shows almost all the functionality the <code>Response</code> object provides. <pre><code>async def hello(req, res: Response, ctx):\n    res.status = HTTPStatus.CREATED\n    res.headers = 'Content-Type', 'application/json'\n    res.body = dumps({'message': 'Why hello there...'})\n\n    # will overwrite res.body above\n    await res.render('index.html')  \n</code></pre></p> <p> </p> <p>Next: Context of Heaven</p>"},{"location":"router/","title":"Min. 5&colon; Application","text":"<p><code>View Source Code:</code> <code>Open on GitHub</code></p>"},{"location":"router/#minute-5","title":"Minute 5","text":""},{"location":"router/#object-4-router-application-app","title":"Object #4: Router | Application | App","text":"<p>A heaven <code>App</code>, <code>Application</code>, or <code>Router</code> can be imported by any of it's aliases and is what you deploy.</p> <pre><code>from heaven import App\nfrom heaven import Router\nfrom heaven import Application\n\nyes = App == Router == Application\n</code></pre>"},{"location":"router/#heaven-is-a-router","title":"Heaven is A Router","text":"<pre><code>router = Router()\n\n\nhandler = lambda req, res, ctx:...\n\n\n# GET, POST, PUT, PATCH, OPTIONS, DELETE, TRACE, all supported\nrouter.GET('/read', handler)\nrouter.POST('/write', handler)\n\n\n# register this handler for all http methods i.e. GET, POST, PUT, OPTIONS, etc...\nrouter.HTTP('/all', handler)\n\n\n# run this handler before all orders routes\nrouter.BEFORE('/orders/*', handler)\n\n# or even after\nrouter.AFTER('/orders/*', handler)\n</code></pre>"},{"location":"router/#additional-router-apis","title":"Additional Router APIs","text":"<ul> <li> <p><code>router.AFTER(url: str, handler: func, subdomain: str)</code> -&gt; This is called a hook - a function that is hooked to run after all matching routes.     <pre><code>message = 'I will run after all /v1/* routes'\nrouter.AFTER('/v1/*', lambda req, res, ctx: print(message))\n\n# will run after\nrouter.GET('/v1/customers', ...)\nrouter.POST('/v1/leads', ...)\n\n# but not after\nrouter.GET('/v2/customers')\n</code></pre></p> </li> <li> <p><code>router.BEFORE(url: str, handler: func, subdomain: str)</code> -&gt; Same as after hook above - but runs before all matching routes.</p> </li> <li> <p><code>router.GET(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a request matches     the provided url. All other HTTP methods <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code> etc.      work in similar fashion. The <code>subdomain</code> optional argument limits the matching to a subdomain.</p> </li> <li> <p><code>router.HTTP(url: str, handler: func)</code> -&gt; Registers your custom handlers/functions to all HTTP methods i.e. GET, PUT, POST, PUT, PATCH instead of doing it individually.</p> </li> <li> <p><code>router.schema</code> -&gt; A registry for attaching metadata (OpenAPI schemas) to routes. It supports <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and <code>PATCH</code> methods.     <pre><code>from heaven import Schema\n\nclass User(Schema):\n    id: int\n    name: str\n\n# Sidecar registration of metadata\napp.schema.POST('/users', expects=User, returns=User, summary=\"Create User\")\n</code></pre></p> <p>[!TIP] Heaven's <code>Schema</code> is a direct export of the high-performance <code>msgspec.Struct</code>. To learn more about advanced features like default values, tagging, and validation, visit the msgspec documentation.</p> </li> <li> <p><code>router.DOCS(route: str, title: str = \"API Reference\", version: str = \"0.0.1\")</code> -&gt; Automatically generates a dynamic <code>openapi.json</code> and serves an interactive Scalar API reference at the provided route.     <pre><code>app.DOCS('/api/docs', title=\"My Insanely Fast API\")\n</code></pre></p> </li> <li> <p><code>router.earth</code> -&gt; The built-in testing utility. It provides a clean API for both integration and unit testing.</p> </li> </ul>"},{"location":"router/#advanced-schema-options","title":"Advanced Schema Options","text":"<p>You can control how Heaven handles incoming and outgoing data using these optional flags in <code>.schema</code> methods:</p> <ul> <li><code>protect: bool</code>: When <code>True</code> (default), Heaven will automatically \"protect\" your response data by removing any fields not present in the <code>returns</code> schema. This is perfect for leak-proofing APIs.</li> <li><code>partial: bool</code>: When <code>True</code>, Heaven allows \"subset matching.\" If your response is missing some fields from the schema, it will still pass (default: <code>False</code>).</li> <li><code>strict: bool</code>: When <code>True</code> (default), output validation failures (missing required fields) will result in a <code>500 Internal Server Error</code>. If <code>False</code>, it will only log a warning and return the data as-is.</li> </ul> <pre><code># Example: Return only what's in User schema, even if DB returns more.\n# Allow missing fields (partial) and just warn on mismatch (strict=False).\napp.schema.GET('/users/:id', returns=User, protect=True, partial=True, strict=False)\n</code></pre> <p>You can also set these globally when initializing your app: <pre><code>app = App(protect_output=True, allow_partials=False, fail_on_output=True)\n</code></pre></p>"},{"location":"router/#integration-testing","title":"Integration Testing","text":"<p>Simulate full requests through the entire framework stack (Hooks, Matching, Handlers, Protection). <pre><code># Returns the actual (req, res, ctx) trio used during the lifecycle\nreq, res, ctx = await app.earth.POST('/users', body={\"name\": \"Ray\"})\n\nassert res.status == 201\nassert res.json['name'] == \"Ray\"\n</code></pre></p>"},{"location":"router/#unit-testing-handlers","title":"Unit Testing Handlers","text":"<p>Use atomic factories to construct a \"trio\" for testing handlers in isolation. <pre><code>from my_handlers import create_user\n\nreq = app.earth.req(url='/users', body={\"name\": \"Jane\"})\nres = app.earth.res()\nctx = app.earth.ctx()\n\nawait create_user(req, res, ctx)\nassert res.status == 201\n</code></pre></p>"},{"location":"router/#lifecycle-session-tracking","title":"Lifecycle &amp; Session Tracking","text":"<p>Use the <code>test()</code> context manager to run <code>STARTUP</code>/<code>SHUTDOWN</code> hooks and track cookies across requests. <pre><code>async with app.earth.test() as earth:\n    # Startup hooks (e.g., DB connections) have run here\n    await earth.POST('/login', body={\"user\": \"admin\"}) # Sets a cookie\n    req, res, ctx = await earth.GET('/dashboard')    # Cookie tracked automatically\n    assert res.status == 200\n</code></pre></p>"},{"location":"router/#subdomain-testing","title":"Subdomain Testing","text":"<p>Heaven is built for subdomains. You can specify which subdomain to target in your tests. <pre><code># Defaults to 'www'\nreq, res, ctx = await app.earth.GET('/api-info', subdomain='api')\nassert res.status == 200\n</code></pre></p>"},{"location":"router/#middleware-bypass","title":"Middleware Bypass","text":"<p>Sometimes you want to test a route but skip a heavy or blocking middleware (like a complex Auth check). <pre><code>app.earth.bypass(heavy_middleware)\n\nasync with app.earth.test() as earth:\n    # heavy_middleware will be skipped for all requests in this block\n    await earth.GET('/fast-route')\n</code></pre></p>"},{"location":"router/#file-uploads","title":"File Uploads","text":"<p>Testing multipart/form-data is easy with the <code>upload</code> helper. <pre><code>files = {'image': b'binary_data_here'}\nreq, res, ctx = await app.earth.upload('/save-avatar', files=files, data={'id': '123'})\nassert res.status == 200\n</code></pre></p>"},{"location":"router/#websocket-testing","title":"WebSocket Testing","text":"<p>Simulate real-time interactions without a real server. <pre><code># 1. Connect\nws = await app.earth.SOCKET('/chat').connect()\n\n# 2. Communicate\nawait ws.send(\"Hello Heaven!\")\nresponse = await ws.receive()\n\n# 3. Cleanup\nawait ws.close()\n</code></pre></p>"},{"location":"router/#mocking-infrastructure","title":"Mocking Infrastructure","text":"<p>Heaven provides two powerful ways to \"unplug\" real services (like databases) during tests.</p> <p>Strategy 1: Hook Swapping If you use <code>app.ON(STARTUP, ...)</code> to connect to a database, you can swap it for a test version before running your tests. <pre><code>async def use_test_db(app):\n    # Connect to a local SQLite instead of Production PG\n    app.keep('db', TestDB())\n\nasync def test_my_app():\n    app.earth.swap(connect_to_real_db, use_test_db)\n    async with app.earth.test() as earth:\n        # STARTUP now runs use_test_db instead\n        await earth.GET('/data')\n</code></pre></p> <p>Strategy 2: Bucket Overwriting Since Heaven handlers rely on \"Buckets\" via <code>app.peek</code>, you can simply overwrite the bucket inside your test block. <pre><code>async def test_simple_mock():\n    async with app.earth.test() as earth:\n        # Overwrite the 'db' bucket with a mock\n        app.keep('db', MockDB())\n\n        await earth.GET('/data')\n        # The handler calling app.peek('db') will get the mock!\n</code></pre></p>"},{"location":"router/#heaven-is-a-global-config-store","title":"Heaven is a Global Config &amp; Store","text":""},{"location":"router/#global-config","title":"Global Config","text":"<p><pre><code>router = Router({'secret_key': 'not so secret...'})\n</code></pre> This will be available in all handlers via the `req.app.CONFIG</p>"},{"location":"router/#additional-storestate-apis","title":"Additional Store/State APIs","text":"<ul> <li> <p><code>router.keep(key: str, value: any)</code> -&gt; Like. <code>c.keep()</code> but persisted across multiple request lifecycles.</p> </li> <li> <p><code>router.peek(key: str, value: any)</code> -&gt; Take a peek at your global dynamic application state without removing the kept value.</p> </li> <li> <p><code>router.unkeep(key: str, value: any)</code> -&gt; Remove and return the kept value from the global dynamic application state. </p> </li> </ul>"},{"location":"router/#customizing-your-heaven-application","title":"Customizing Your Heaven Application","text":"<pre><code># development\nfrom aiomysql import connect as Connection\nfrom redis import Redis\nfrom heaven import App  # also available as Router, Application\n\n\napp = App()\n\n\n# adding a database connection?\nasync def database_middleware(router: Router):\n    client = await Connection(host='localhost', port=3306, user='root', password='', db='mysql')\n    router.keep('db', client)\n\n\n# synchronous initialization also supported\ndef upredis(router: Router):\n    redis = Redis('localhost')\n    router.keep('redis', redis)\n\n\n# now use it in your handlers\nasync def create_order(req: Request, res: Response, ctx: Context):\n    db: Connection = req.app.peek('db')\n    await db.execute('''INSERT ...''')\n\n\napp.ON(STARTUP, updatabase)\napp.ON(SHUTDOWN, downdatabase)\napp.ONCE(upredis)\n\n\napp.POST('/orders', create_order)\n</code></pre>"},{"location":"router/#daemons-native-background-tasks","title":"Daemons: Native Background Tasks \ud83d\udc7b","text":"<p>Daemons are one of Heaven's most powerful features. They are long-running background tasks that live for the entire lifecycle of your application.</p> <p>The Blocking Rule</p> <p>Heaven runs on a single-threaded event loop. If you write a background task that performs heavy computation or blocking I/O (like <code>time.sleep()</code>), it will freeze the entire server. </p> <p>Note: As of version 0.6.2, Heaven automatically offloads synchronous daemons to a separate thread pool to prevent accidental freezes, but using <code>async</code> functions remains the gold standard for performance.</p> <p>Unlike FastAPI or Flask, which often require external libraries like Celery or Dramatiq for background processing, Heaven has background workers built directly into the core.</p>"},{"location":"router/#why-daemons-are-powerful","title":"Why Daemons are powerful:","text":"<ol> <li>Periodic Jobs: Easily run a task every <code>X</code> seconds (like a heartbeat or cache warmer).</li> <li>Event Loops: Listen to a message queue or a database stream in the background.</li> <li>Internal Tools: Run health checks or cleanup scripts without affecting request latency.</li> </ol>"},{"location":"router/#creating-a-daemon","title":"Creating a Daemon","text":"<p>A daemon is just a function that takes the <code>app</code> instance as its only argument.</p> <pre><code>async def my_daemon(app):\n    print(\"Doing background work...\")\n\n    # If you return a number, the daemon will sleep for that many \n    # seconds and then run again automatically.\n    return 10 \n\napp.daemons = my_daemon\n</code></pre> <p>If you return <code>None</code> or <code>False</code>, the daemon will run exactly once and then stop.</p>"},{"location":"router/#2-running-your-heaven-application-in-production","title":"2. Running your heaven application in production","text":"<pre><code># development\nuvicorn application:router --reload\n\n# production\ngunicorn -w 4 -k uvicorn.workers.UvicornWorker application:router\n</code></pre> <p>Replace the number after <code>-w</code> with the number of processors you desire to run your app with.</p> <p>Slow Down Tiger</p> <p>You might be asking - what about the applications port number etc? \ud83d\ude01</p>"},{"location":"snippets/","title":"Minute 9: Centralized Middleware &amp; Snippets","text":"<p>Heaven is extremely unopinionated, but it provides powerful tools for centralized control. This section shows how to use <code>.BEFORE</code> hooks for common tasks like Authentication and Data Validation.</p>"},{"location":"snippets/#centralized-authentication","title":"Centralized Authentication","text":"<p>Instead of littering your handlers with decorators, use <code>.BEFORE</code> to protect entire route trees at once.</p> <pre><code>from http import HTTPStatus\nfrom heaven import App, Request, Response, Context\n\napp = App()\n\n# 1. Define your protection logic\nasync def protect(req: Request, res: Response, ctx: Context):\n    token = req.headers.get('authorization')\n\n    # Use your preferred JWT or other validation scheme here\n    if not token or token != \"secret-token\":\n        # res.abort stops the request cycle immediately\n        res.abort('Unauthorized Access', status=HTTPStatus.UNAUTHORIZED)\n        return\n\n    # Keep the user in context for the actual handler\n    ctx.keep('user', {\"id\": 1, \"name\": \"Raymond\"})\n\n# 2. Register it globally or for specific route patterns\napp.BEFORE('/api/v1/*', protect)\n\n# 3. Your handler stays clean and focused\nasync def get_secure_data(req: Request, res: Response, ctx: Context):\n    user = ctx.user # Already populated by the hook\n    res.body = {\"data\": \"Top Secret\", \"for\": user['name']}\n\napp.GET('/api/v1/data', get_secure_data)\n</code></pre>"},{"location":"snippets/#centralized-data-validation","title":"Centralized Data Validation","text":"<p>You can also use <code>.BEFORE</code> to validate incoming data before it ever reaches your handler.</p> <pre><code>import json\nfrom heaven import App, Request, Response, Context\n\napp = App()\n\nasync def validate_json(req: Request, res: Response, ctx: Context):\n    try:\n        data = json.loads(req.body)\n        if \"email\" not in data:\n            raise ValueError(\"Email is required\")\n        ctx.keep('payload', data)\n    except Exception as e:\n        res.abort(f\"Invalid Data: {str(e)}\", status=400)\n\napp.BEFORE('/api/v1/login', validate_json)\n\nasync def login(req: Request, res: Response, ctx: Context):\n    payload = ctx.payload\n    print(f\"Logging in {payload['email']}\")\n    res.body = {\"status\": \"ok\"}\n\napp.GET('/api/v1/login', login)\n</code></pre> <p>[!TIP] Use <code>.BEFORE('*', handler)</code> to run a hook for every single request in your application (e.g., for logging or CORS).</p>"}]}