{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Heaven v1.0","text":""},{"location":"#welcome-to-heaven","title":"Welcome To Heaven","text":"<p>You are probably here because you want to build a web application using Python. Well, Welcome to heaven - the super simple, extremely fast, web framework for purists.</p> <p>Building a web application with heaven is stupid simple as the code snippet below shows</p> <pre><code>from heaven import Router  # also available as App, Application\n\n# create your web app i.e. a simple router/multiplexer\napp = Router()\n</code></pre> <p>And to run your new app from heaven?</p> <pre><code>$ uvicorn app:app --port 5000 --reload\n</code></pre>"},{"location":"#heavens-goals-vs-building-useful-apps","title":"Heaven's Goals vs Building Useful Apps","text":"<p>Heaven was designed with 3 goals in mind. The example above creates a simple heaven app but it does not do anything useful.</p> <p>But, what do we mean when we say an app is useful, and how does it relate to Heaven's Goals?</p> <p>In our opinion a useful app(s):</p> <ol> <li>Solves a problem</li> <li>Is extremely simple to learn (Mastery in 10mins or less)</li> <li>Is optimized for speed</li> </ol> <p>These are also Heaven's goals.</p> <ul> <li> <p>Heaven solves the framework mastery problem - Enabling engineers build APIs and Web Applications that also embody Heaven's goals.</p> </li> <li> <p>Is super simple to learn - in line with it's goal of <code>Mastery in 10 mins or less</code>. If you find a  python web framework easier to learn than Heaven, use it.</p> </li> <li> <p>Faster than Django, Flask, Pyramid etc. and will get even faster as it is optimized further.</p> </li> </ul>"},{"location":"#why-another-python-web-framework","title":"Why Another Python Web Framework?","text":"<p>Because we needed something small enough to be learnt completely by new engineers in less than 10 minutes. Complete mastery with no gray spots.</p>"},{"location":"#okay-what-next","title":"Okay, What Next?","text":"<ul> <li> <p>Minute 1: Quickstart : Toe in the water</p> </li> <li> <p>Minute 2: Heaven Application</p> </li> <li> <p>Minute 3: Request to Heaven</p> </li> <li> <p>Minute 4: Responses from Heaven</p> </li> <li> <p>Minute 5: Context of Heaven</p> </li> <li> <p>Minute 6: Rendering HTML Templates &amp; Public Assets</p> </li> <li> <p>Minute 7: Drink some coffee</p> </li> <li> <p>Minute 8: Mounting Applications</p> </li> <li> <p>Minute 9: Authentication &amp; Data Validation Guidelines/Code Snippets</p> </li> <li> <p>Minute 10: Congratulate Yourself</p> </li> </ul>"},{"location":"api/","title":"Minute 1","text":"<p>We are assuming you have installed heaven via <code>pip install heaven</code>. If no, then go ahead and install it, otherwise let's dive in.</p>"},{"location":"api/#30000-foot-view","title":"30,000 Foot View...","text":"<pre><code>from heaven import Router\n\n\nrouter = Router()\n\n\nrouter.GET('/v1/customers', lambda r, w, c: pass)\n</code></pre>"},{"location":"congrats/","title":"Minute 10&colon; Congratulate Yourself","text":""},{"location":"congrats/#before-you-go-how-about-some-cheat-codes-","title":"Before you go... How about some cheat codes ;-)","text":"<p>We use heaven extensively to power numerous enterprise microservices and have collated some practices that might help you get there even faster.</p>"},{"location":"congrats/#decorators","title":"Decorators","text":"<p>In this example we use the <code>jsonschema</code> library to pass along validated data to our eventual handlers</p> <pre><code>from asyncio import iscoroutinefunction\nfrom functools import wraps\nfrom http import HTTPStatus\n\nfrom jsonschema import validate\nfrom jsonschema.exceptions import ValidationError\nfrom ujson import dumps, loads\n\n\ndef expects(schema: dict):\n    def wrapper(func):\n        @wraps(func)\n        async def delegate(r: Request, w: Response, c: Context):\n            try: json = loads(r.body)\n            except:\n                return w.status = HTTPStatus.UNPROCESSABLE_ENTITY\n\n            try: validate(schema, json, draft7_format_checker=True)\n            except ValidationError as exc:\n                w.body = dumps(exc)\n                return w.status = status.BAD_REQUEST\n\n            # little helper used in example handler below -&gt; c.age, c.email\n            for key in json: c.keep(key, json.get(key))\n\n            # so you can wrap async and non async handler variants\n            if iscoroutinefunction(func): return await func(r, w, c)\n            else: return func(r, w, c)\n        return delegate\n    return wrapper\n\n\n@expects({\n    'type': 'object',\n    'properties': {\n        'age': {'type': 'number', 'min': 18, 'max': 180},\n        'email': {'type': 'string', 'format': 'email'}\n    },\n    'required': ['age', 'email'],\n    'additionalProperties': false,\n})\nasync def create_customer_order(r: Request, w: Response, c: Context):\n    dbpool = r.app.peek('dbpool')\n    async with dbpool.acquire() as sqld:\n        try:\n            identifier = sqld.execute('... returning id')\n        except UniqueViolationsError:\n            return w.status = status.SERVICE_UNAVAILABLE\n\n    w.status = HTTPStatus.CREATED\n    w.body = dumps({\n        'identifier': identifier,\n        'age': c.age,\n        'email': c.email\n    })\n</code></pre> <p>This example demonstrates one of the ways Authentication might be implemented with the <code>pyjwt</code> library. <pre><code>from asyncpg import Pool\nfrom jwt import decode\n\n\ndef private(role: str):\n\"\"\"RBAC Authorization, heaven makes it easy to also use ABAC\"\"\"\n    def wrapper(func):\n        @wraps(func)\n        def delegate(r: Request, w: Response, c: Context):\n            dbpool: Pool = r.app.peek('dbpool')\n            with dbpool.acquire() as sqld:\n                try: roles = await sqld.fetchval(\"\"\"\n                    SELECT roles\n                    FROM privileges\n                    WHERE user = $1 AND action = $2\n                \"\"\", c.current_user, f'{r.method.lower()}s')\n                except:\n                    w.status = HTTPStatus.SERVICE_UNAVAILABLE\n                    w.body = dumps({'message': 'please try again later'})\n            if role in roles: return await func(r, w, c)\n\n            w.status = HTTPStatus.UNAUTHORIZED\n            w.body = dumps({'message': 'insufficient privileges'})\n        return delegate\n    return wrapper\n\n\ndef protected(func):\n\"\"\"Authentication\"\"\"\n    @wraps(func)\n    def delegate(r: Request, w: Response, c: Context):\n        token = r.headers.get('authorization')\n        secret_key = r.app.CONFIG('SECRET_KEY')\n\n        try: credentials = decode(token, secret_key, algorithm='HS256')\n        except: return w.status = status.UNAUTHORIZED\n        else: c.keep('current_user') = credentials.get('id')\n\n        return await func(r, w, c)\n    return delegate\n</code></pre></p>"},{"location":"context/","title":"Minute 9: Guidelines and Code Snippets","text":"<p>Heaven is extremely unopinionated. Using python decorators; this section shows a few ways to combine standard python libraries like pydantic, PyJWT etc. with heaven.</p>"},{"location":"context/#authentication-example","title":"Authentication Example","text":"<pre><code>from functools import wraps\nfrom inspect import iscoroutinefunction\n\n# typing is amazing let's use it as much as we can\nfrom heaven import Context, Request, Response\n\n\ndef protect(func):\n    @wraps(func)\n    async def delegate(req: Request, res: Response, ctx: Context):\n        token = req.headers.get('authorization')\n\n        # use your preferred jwt or other validation lib/scheme here\n        if not token:\n            res.status = HTTPStatus.UNAUTHORIZED\n            res.body = 'Whatever body you want'\n            return\n\n        ctx.keep('user', {...})\n        if iscoroutinefunction(handler): await func(req, res, ctx)\n        else: func(req, res, ctx)\n    return delegate\n\n\n# use decorator to protect handler(s) of choice\n@protect\nasync def get_customer_info(req: Request, res: Response, ctx: Context):\n    res.body = {}\n</code></pre>"},{"location":"context/#data-validation-example","title":"Data Validation Example","text":"<pre><code>from heaven import ...  # necessary imports here\nfrom pydantic import BaseModel\n\n\nclass Guest(BaseModel):\n    email: EmailStr\n    password: str\n\n\ndef expects(model: BaseModel):\n    async def delegate(req: Request, res: Response, ctx: Context):\n        try:\n            data = loads(req.body)\n            guest = Guest(**data)\n        except:  # be more specific with exceptions in production code\n            res.status = HTTPStatus.BAD_REQUEST\n            return\n        ctx.keep('guest', Guest)\n    return delegate\n\n\n@expects(Guest)\nasync def do_login_with_email(req: Request, res: Response, ctx: Context):\n    guest: Guest = ctx.guest\n    print(guest.email)\n    print(guest.password)\n</code></pre>"},{"location":"html/","title":"Minute 9: Guidelines and Code Snippets","text":"<p>Heaven is extremely unopinionated. Using python decorators; this section shows a few ways to combine standard python libraries like pydantic, PyJWT etc. with heaven.</p>"},{"location":"html/#authentication-example","title":"Authentication Example","text":"<pre><code>from functools import wraps\nfrom inspect import iscoroutinefunction\n\n# typing is amazing let's use it as much as we can\nfrom heaven import Context, Request, Response\n\n\ndef protect(func):\n    @wraps(func)\n    async def delegate(req: Request, res: Response, ctx: Context):\n        token = req.headers.get('authorization')\n\n        # use your preferred jwt or other validation lib/scheme here\n        if not token:\n            res.status = HTTPStatus.UNAUTHORIZED\n            res.body = 'Whatever body you want'\n            return\n\n        ctx.keep('user', {...})\n        if iscoroutinefunction(handler): await func(req, res, ctx)\n        else: func(req, res, ctx)\n    return delegate\n\n\n# use decorator to protect handler(s) of choice\n@protect\nasync def get_customer_info(req: Request, res: Response, ctx: Context):\n    res.body = {}\n</code></pre>"},{"location":"html/#data-validation-example","title":"Data Validation Example","text":"<pre><code>from heaven import ...  # necessary imports here\nfrom pydantic import BaseModel\n\n\nclass Guest(BaseModel):\n    email: EmailStr\n    password: str\n\n\ndef expects(model: BaseModel):\n    async def delegate(req: Request, res: Response, ctx: Context):\n        try:\n            data = loads(req.body)\n            guest = Guest(**data)\n        except:  # be more specific with exceptions in production code\n            res.status = HTTPStatus.BAD_REQUEST\n            return\n        ctx.keep('guest', Guest)\n    return delegate\n\n\n@expects(Guest)\nasync def do_login_with_email(req: Request, res: Response, ctx: Context):\n    guest: Guest = ctx.guest\n    print(guest.email)\n    print(guest.password)\n</code></pre>"},{"location":"mount/","title":"Heaven","text":"<p>Super small micro framework for building enterprise microservices and or web applications.</p>"},{"location":"mount/#why-another-python-web-framework","title":"Why Another Python Web Framework?","text":"<p>Because we needed something small enough to be learnt completely by new engineers in less than 5 minutes. Complete mastery with no gray spots.</p>"},{"location":"quickstart/","title":"Minute 1","text":"<p>We are assuming you have installed heaven via <code>pip install heaven</code>. If no, then go ahead and install it; If you have, then the clock is ticking so let's dive in.</p>"},{"location":"quickstart/#1-create-a-handler-function","title":"1. Create a handler function","text":"<pre><code>import json\nfrom http import HTTPStatus\n\nfrom heaven import Request, Response, Context\n\nasync def get_one_customer(r: Request, w: Response, c: Context):\n    id = r.params.get('id')\n    w.status = HTTPStatus.CREATED\n    w.body = json.dumps({\"message\": f\"heaven is easy for customer {id}\"})\n</code></pre> <p>As you can see above - your handler function can be async if you desire and must accept 3 arguments that will be injected by heaven. We'll get back to them in Minute 3</p>"},{"location":"quickstart/#2-connect-your-handler-to-the-heaven-application","title":"2. Connect your handler to the heaven application","text":"<pre><code>from heaven import Router\n\n# create the application\nrouter = Router()\n\n# connect it to a route\nrouter.GET('/v1/customers/:id', get_one_customer)\n</code></pre> <p>All HTTP methods i.e. <code>GET</code>, <code>POST</code> etc. are all supported</p> <p> </p>"},{"location":"quickstart/#minute-2","title":"Minute 2","text":"<p>That was quick wasn't it? even less than a minute?</p> <p>Well now we have an application, but it is no fun if we can't execute/run/interact with it.</p>"},{"location":"quickstart/#3-run-your-heaven-application","title":"3. Run your heaven application","text":"<pre><code># development\nuvicorn application:router --reload\n\n# production\ngunicorn -w 4 -k uvicorn.workers.UvicornWorker application:router\n</code></pre> <p>Replace the number after <code>-w</code> with the number of processors you desire to run your app with.</p> <p>Slow Down Tiger</p> <p>You might be asking - what about the applications port number etc? \ud83d\ude01</p> <p> </p>"},{"location":"quickstart/#minute-3-4","title":"Minute 3 &amp; 4","text":"<p>A promise is a promise. So it's time to tell you about heaven's objects. Don't fret - there are only 4 of them.</p>"},{"location":"quickstart/#1-request","title":"1. Request","text":"<p>All handlers will receive this as their first argument i.e. <code>...(r: Request, ..., ...)</code> and all Request objects come with the following bag of goodies.</p> <ul> <li> <p><code>r.app: Router</code> -&gt; An instance of the base heaven application</p> </li> <li> <p><code>r.body: dict</code> -&gt; The body sent along with the request</p> </li> <li> <p><code>r.cookies: dict</code> -&gt; All the cookies sent with request [keys in lowercase]</p> </li> <li> <p><code>r.headers: dict</code> -&gt; All the headers sent with request [keys in lowercase]</p> </li> <li> <p><code>r.method: str</code> -&gt; <code>GET</code>, <code>POST</code>, <code>DELETE</code>? What method type is the http request</p> </li> <li> <p><code>r.params: dict</code> -&gt; Querystring parameters and url masks <code>/customers/:param1</code> parsed into a dictionary</p> </li> <li> <p><code>r.querystring: str</code> -&gt; The part after the <code>?</code> i.e. example.com**?age=34** parsed in comma separated string form</p> </li> <li> <p><code>r.subdomain: str</code> -&gt; If request was made to a subdomain i.e. <code>www.example.org</code> or <code>api.example.org</code> then this holds the subdomain value e.g. <code>www</code> and <code>api</code>.</p> </li> <li> <p><code>r.url: str</code> -&gt; The url that matched to this handler as sent by the client</p> </li> </ul>"},{"location":"quickstart/#2-response","title":"2. Response","text":"<p>All handlers receive this as the second argument i.e. <code>...(..., w: Response, ...)</code> as Responses help with responding to Requests.</p> <ul> <li> <p><code>w.abort(payload: any)</code> -&gt; If this is calledx then all <code>PRE</code> and <code>POST</code> hooks will be aborted</p> </li> <li> <p><code>w.body: any</code> -&gt; This will be sent back as the body of the response</p> </li> <li> <p><code>w.headers: tuple[2] | list[2]</code> -&gt; How headers are set i.e. <code>w.headers = 'Set-Cookie', 'Token=12345; Max-Age=8700; Secure; HttpOnly'</code></p> </li> <li> <p><code>w.status: int</code> -&gt; HTTP status code to be sent back with the response</p> </li> </ul>"},{"location":"quickstart/#3-context","title":"3. Context","text":"<p>All handlers receive this as the third argument i.e. <code>...(..., ..., c: Context)</code> to help with preserving state across a request lifecycle i.e. from start/reciept to finish/response.</p> <ul> <li><code>c.keep(alias: str, value: any)</code> -&gt; Save something that can be retrieved via Python descriptor semantics. i.e. <code>c.alias</code> will return the kept value.</li> </ul>"},{"location":"quickstart/#4-router","title":"4. Router","text":"<p>This is the last internal heaven object to grok. You can instantiate it with an optional configuration that is stored as the application's global state. <pre><code>router = Router({'secret_key': '...'})\n# or\nrouter = Router(function() -&gt; dict)\n</code></pre></p> <ul> <li> <p><code>router.AFTER(url: str, handler: func, subdomain: str)</code> -&gt; Get a config value from the global store/state register</p> </li> <li> <p><code>router.BEFORE(url: str, handler: func, subdomain: str)</code> -&gt; Get a config value from the global store/state register</p> </li> <li> <p><code>router.CONFIG(url: str, handler: func, subdomain: str)</code> -&gt; Get a config value from the <code>final readonly</code> app config set at router instantiation.</p> </li> <li> <p><code>router.GET(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a url match is made. <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code> etc. all work in similar fashion. The <code>subdomain</code> optional argument limits the matching to a subdomain.</p> </li> <li> <p><code>router.HTTP(url: str, handler: func)</code> -&gt; Registers your custom handlers/functions to all HTTP methods i.e. GET, PUT, POST, PUT, PATCH instead of doing it individually.</p> </li> <li> <p><code>router.keep(key: str, value: any)</code> -&gt; Like. <code>c.keep()</code> but persisted across multiple request lifecycles.</p> </li> <li> <p><code>router.peek(key: str, value: any)</code> -&gt; Take a peek at your global dynamic application state without removing the kept value.</p> </li> <li> <p><code>router.unkeep(key: str, value: any)</code> -&gt; Remove and return the kept value from the global dynamic application state. </p> </li> </ul> <p> </p>"},{"location":"quickstart/#minute-5-faqs-anyone","title":"Minute 5 : FAQs Anyone?","text":"<p>Whew... You made it here, we are super proud of you.</p> <p>One last thing and you will be all set to create anything with a shiny powerful web framework. It's time to answer your questions.</p> <ol> <li> <p>What of authentication and authorization?</p> <p>Routerling is a microframwork so you have to roll your own which is pretty simple to do with python decorators.</p> </li> <li></li> </ol>"},{"location":"request/","title":"Minute 9: Guidelines and Code Snippets","text":"<p>Heaven is extremely unopinionated. Using python decorators; this section shows a few ways to combine standard python libraries like pydantic, PyJWT etc. with heaven.</p>"},{"location":"request/#authentication-example","title":"Authentication Example","text":"<pre><code>from functools import wraps\nfrom inspect import iscoroutinefunction\n\n# typing is amazing let's use it as much as we can\nfrom heaven import Context, Request, Response\n\n\ndef protect(func):\n    @wraps(func)\n    async def delegate(req: Request, res: Response, ctx: Context):\n        token = req.headers.get('authorization')\n\n        # use your preferred jwt or other validation lib/scheme here\n        if not token:\n            res.status = HTTPStatus.UNAUTHORIZED\n            res.body = 'Whatever body you want'\n            return\n\n        ctx.keep('user', {...})\n        if iscoroutinefunction(handler): await func(req, res, ctx)\n        else: func(req, res, ctx)\n    return delegate\n\n\n# use decorator to protect handler(s) of choice\n@protect\nasync def get_customer_info(req: Request, res: Response, ctx: Context):\n    res.body = {}\n</code></pre>"},{"location":"request/#data-validation-example","title":"Data Validation Example","text":"<pre><code>from heaven import ...  # necessary imports here\nfrom pydantic import BaseModel\n\n\nclass Guest(BaseModel):\n    email: EmailStr\n    password: str\n\n\ndef expects(model: BaseModel):\n    async def delegate(req: Request, res: Response, ctx: Context):\n        try:\n            data = loads(req.body)\n            guest = Guest(**data)\n        except:  # be more specific with exceptions in production code\n            res.status = HTTPStatus.BAD_REQUEST\n            return\n        ctx.keep('guest', Guest)\n    return delegate\n\n\n@expects(Guest)\nasync def do_login_with_email(req: Request, res: Response, ctx: Context):\n    guest: Guest = ctx.guest\n    print(guest.email)\n    print(guest.password)\n</code></pre>"},{"location":"response/","title":"Minute 9: Guidelines and Code Snippets","text":"<p>Heaven is extremely unopinionated. Using python decorators; this section shows a few ways to combine standard python libraries like pydantic, PyJWT etc. with heaven.</p>"},{"location":"response/#authentication-example","title":"Authentication Example","text":"<pre><code>from functools import wraps\nfrom inspect import iscoroutinefunction\n\n# typing is amazing let's use it as much as we can\nfrom heaven import Context, Request, Response\n\n\ndef protect(func):\n    @wraps(func)\n    async def delegate(req: Request, res: Response, ctx: Context):\n        token = req.headers.get('authorization')\n\n        # use your preferred jwt or other validation lib/scheme here\n        if not token:\n            res.status = HTTPStatus.UNAUTHORIZED\n            res.body = 'Whatever body you want'\n            return\n\n        ctx.keep('user', {...})\n        if iscoroutinefunction(handler): await func(req, res, ctx)\n        else: func(req, res, ctx)\n    return delegate\n\n\n# use decorator to protect handler(s) of choice\n@protect\nasync def get_customer_info(req: Request, res: Response, ctx: Context):\n    res.body = {}\n</code></pre>"},{"location":"response/#data-validation-example","title":"Data Validation Example","text":"<pre><code>from heaven import ...  # necessary imports here\nfrom pydantic import BaseModel\n\n\nclass Guest(BaseModel):\n    email: EmailStr\n    password: str\n\n\ndef expects(model: BaseModel):\n    async def delegate(req: Request, res: Response, ctx: Context):\n        try:\n            data = loads(req.body)\n            guest = Guest(**data)\n        except:  # be more specific with exceptions in production code\n            res.status = HTTPStatus.BAD_REQUEST\n            return\n        ctx.keep('guest', Guest)\n    return delegate\n\n\n@expects(Guest)\nasync def do_login_with_email(req: Request, res: Response, ctx: Context):\n    guest: Guest = ctx.guest\n    print(guest.email)\n    print(guest.password)\n</code></pre>"},{"location":"router/","title":"Minute 9: Guidelines and Code Snippets","text":"<p>Heaven is extremely unopinionated. Using python decorators; this section shows a few ways to combine standard python libraries like pydantic, PyJWT etc. with heaven.</p>"},{"location":"router/#authentication-example","title":"Authentication Example","text":"<pre><code>from functools import wraps\nfrom inspect import iscoroutinefunction\n\n# typing is amazing let's use it as much as we can\nfrom heaven import Context, Request, Response\n\n\ndef protect(func):\n    @wraps(func)\n    async def delegate(req: Request, res: Response, ctx: Context):\n        token = req.headers.get('authorization')\n\n        # use your preferred jwt or other validation lib/scheme here\n        if not token:\n            res.status = HTTPStatus.UNAUTHORIZED\n            res.body = 'Whatever body you want'\n            return\n\n        ctx.keep('user', {...})\n        if iscoroutinefunction(handler): await func(req, res, ctx)\n        else: func(req, res, ctx)\n    return delegate\n\n\n# use decorator to protect handler(s) of choice\n@protect\nasync def get_customer_info(req: Request, res: Response, ctx: Context):\n    res.body = {}\n</code></pre>"},{"location":"router/#data-validation-example","title":"Data Validation Example","text":"<pre><code>from heaven import ...  # necessary imports here\nfrom pydantic import BaseModel\n\n\nclass Guest(BaseModel):\n    email: EmailStr\n    password: str\n\n\ndef expects(model: BaseModel):\n    async def delegate(req: Request, res: Response, ctx: Context):\n        try:\n            data = loads(req.body)\n            guest = Guest(**data)\n        except:  # be more specific with exceptions in production code\n            res.status = HTTPStatus.BAD_REQUEST\n            return\n        ctx.keep('guest', Guest)\n    return delegate\n\n\n@expects(Guest)\nasync def do_login_with_email(req: Request, res: Response, ctx: Context):\n    guest: Guest = ctx.guest\n    print(guest.email)\n    print(guest.password)\n</code></pre>"},{"location":"snippets/","title":"Minute 9: Guidelines and Code Snippets","text":"<p>Heaven is extremely unopinionated. Using python decorators; this section shows a few ways to combine standard python libraries like pydantic, PyJWT etc. with heaven.</p>"},{"location":"snippets/#authentication-example","title":"Authentication Example","text":"<pre><code>from functools import wraps\nfrom inspect import iscoroutinefunction\n\n# typing is amazing let's use it as much as we can\nfrom heaven import Context, Request, Response\n\n\ndef protect(func):\n    @wraps(func)\n    async def delegate(req: Request, res: Response, ctx: Context):\n        token = req.headers.get('authorization')\n\n        # use your preferred jwt or other validation lib/scheme here\n        if not token:\n            res.status = HTTPStatus.UNAUTHORIZED\n            res.body = 'Whatever body you want'\n            return\n\n        ctx.keep('user', {...})\n        if iscoroutinefunction(handler): await func(req, res, ctx)\n        else: func(req, res, ctx)\n    return delegate\n\n\n# use decorator to protect handler(s) of choice\n@protect\nasync def get_customer_info(req: Request, res: Response, ctx: Context):\n    res.body = {}\n</code></pre>"},{"location":"snippets/#data-validation-example","title":"Data Validation Example","text":"<pre><code>from heaven import ...  # necessary imports here\nfrom pydantic import BaseModel\n\n\nclass Guest(BaseModel):\n    email: EmailStr\n    password: str\n\n\ndef expects(model: BaseModel):\n    async def delegate(req: Request, res: Response, ctx: Context):\n        try:\n            data = loads(req.body)\n            guest = Guest(**data)\n        except:  # be more specific with exceptions in production code\n            res.status = HTTPStatus.BAD_REQUEST\n            return\n        ctx.keep('guest', Guest)\n    return delegate\n\n\n@expects(Guest)\nasync def do_login_with_email(req: Request, res: Response, ctx: Context):\n    guest: Guest = ctx.guest\n    print(guest.email)\n    print(guest.password)\n</code></pre>"},{"location":"tutorials/router/","title":"Quickstart Tutorial","text":"<pre><code>$ uvicorn main:app --reload\n\n&lt;span style=\"color: green;\"&gt;INFO&lt;/span&gt;:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n&lt;span style=\"color: green;\"&gt;INFO&lt;/span&gt;:     Started reloader process [28720]\n&lt;span style=\"color: green;\"&gt;INFO&lt;/span&gt;:     Started server process [28722]\n&lt;span style=\"color: green;\"&gt;INFO&lt;/span&gt;:     Waiting for application startup.\n&lt;span style=\"color: green;\"&gt;INFO&lt;/span&gt;:     Application startup complete.\n---&gt; 100%\n</code></pre> <p>There are 4 ways to query your data using SuperSQL</p> <ul> <li>Identifier Interpolation</li> <li>Manually create a Table schema</li> <li>Automatically reflect tables from the database</li> <li>Use <code>dict</code> and <code>list</code> with variables</li> </ul> <p> </p>"},{"location":"tutorials/router/#identifier-interpolation","title":"Identifier Interpolation","text":"<pre><code>from os import environ\nfrom supersql import Query\n\nuser = environ.get('DB_USER')\npwd = environ.get('DB_PWD')\ndialect = environ.get('DB_ENGINE')\n\nquery = Query(vendor=dialect, user=user, password=pwd)\n\nresults = query.SELECT(\n    \"first_name\", \"last_name\", \"email\"\n).FROM(\n    \"employees\"\n).WHERE(\n    \"email = 'someone@example.com'\"  # WARNING: don't inject user provided values (SQL Injection Possible)\n).run()\n</code></pre> <p>Magic Literals Are Bad</p> <p>It is usually not advisable to repeat string or other constants in multiple places across your codebase. If you notice string or literal values repeating more than once consider turning them into constants.</p> <p>Identifiers ONLY</p> <p>It is advisable to limit use of strings to only identifiers e.g. <code>column names</code>, <code>table names</code>, <code>...</code> and operators <code>=</code>, <code>&lt;&gt;</code> etc.</p> <p> </p>"},{"location":"tutorials/router/#manually-create-table-schema","title":"Manually Create Table Schema","text":"<pre><code>from supersql import Table\n\n\nclass Employee(Table):...\n\n\nemp = Employee()\n\n\nresults = query.SELECT(\n    emp.first_name, emp.last_name, emp.email\n).FROM(\n    emp\n).WHERE(\n    emp.email == 'someone@example.com'\n).execute()  # `execute` fetches all data into memory\n</code></pre> <p>Run vs Execute</p> <p><code>execute()</code> fetches all data into memory. Do not use with unsafe queries to large tables e.g. <code>SELECT * FROM very_large_table</code>. Use <code>run()</code> as it fetches data in chunks and reconnects as necessary to fetch more data.</p> <p> </p>"},{"location":"tutorials/router/#auto-reflect-table-schema","title":"Auto-Reflect Table Schema","text":"<pre><code>...\n\n\ntables = query.database(\"dbname\").tables()\nemp = tables.get(\"employees\")\n\n\nresults = query.SELECT(\n    emp.first_name, emp.last_name, emp.email\n).FROM(\n    emp\n).WHERE(\n    emp.email == 'someone@example.com'\n).execute()\n</code></pre>"},{"location":"tutorials/router/#use-dict-lists-with-variables","title":"Use Dict &amp; Lists with Variables","text":"<pre><code>from supersql import Query\n\nquery = Query(...)  # connection parameters as required\n\ndef example(table, *args, **kwargs)\n    alt_results = query.SELECT(*args).FROM(table).WHERE(**kwargs).run()\n</code></pre>"},{"location":"tutorials/router/#okay-how-about-inserting-data","title":"Okay... How about inserting Data?","text":"<p>Adding or inserting data with SuperSQL is just as easy as querying data.</p> <p>However it is important for you to understand that SuperSQL is NOT AN ORM, and that means you can't use some magical <code>table.save()</code> method to insert data to the database.</p> <p>That's now how we roll... \u00a0 \u00a0 :smile:</p> <p>So how then do you insert data? Let's look at some code.</p> <pre><code># borrowing Query and Employee code from above\n...\n\ndef insert(**kwargs):\n    result = query.INSERT(\n        emp\n    ).VALUES(\n        **kwargs\n    ).execute()\n\n\ndef bulk_insert(*args):\n    result = query.INSERT(\n        emp.first_name,\n        emp.last_name,\n        emp.email\n    ).VALUES(\n        args\n    ).execute()\n\n\ndef insert_with_into(*args):\n    # Use of INTO(table) used here is 100% optional but arguably\n    # adds readability\n    results = Query.INSERT(\n        emp.first_name, emp.last_name, emp.email\n    ).INTO(\n        emp\n    ).VALUES(\n        [\"John\", \"Doe\", \"john.doe@example.net\"] if not args else args\n    ).execute()\n\nquery.INSERT().INTO().VALUES().WHERE_NOT_EXISTS()\n</code></pre>"}]}