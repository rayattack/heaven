{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Heaven v1.0","text":""},{"location":"#welcome-to-heaven","title":"Welcome To Heaven","text":"<p>You are probably here because you want to build a web application using Python. Well, Welcome to heaven - the super simple, extremely fast, web framework for purists.</p> <p>Building a web application with heaven is stupid simple as the code snippet below shows</p> <pre><code>from heaven import Router  # also available as App, Application\n\n# create your web app i.e. a simple router/multiplexer\napp = Router()\n\napp.ASSETS('assets_folder_path')\napp.TEMPLATES('templates_folder_path')\n\n# for async support use an async func/method not a lambda\napp.GET('/', lambda req, res, ctx: res.renders('index.html'))\n</code></pre> <p>And to run your new app from heaven?</p> <p><pre><code>$ uvicorn app:app --port 5000 --reload\n</code></pre> </p>"},{"location":"#heavens-goals-vs-building-useful-apps","title":"Heaven's Goals vs Building Useful Apps","text":"<p>Heaven was designed with 3 goals in mind. The example above creates a simple heaven app but it does not do anything useful.</p> <p>But, what do we mean when we say an app is useful, and how does it relate to Heaven's Goals?</p> <p>In our opinion a useful app(s):</p> <ol> <li>Solves a problem</li> <li>Is extremely simple to learn (Mastery in 10mins or less)</li> <li>Is optimized for speed</li> </ol> <p>These are also Heaven's goals.</p> <ul> <li> <p>Heaven solves the framework mastery problem - Enabling engineers build APIs and Web Applications that also embody Heaven's goals.</p> </li> <li> <p>Is super simple to learn - in line with it's goal of <code>Mastery in 10 mins or less</code>. If you find a  python web framework easier to learn than Heaven, use it.</p> </li> <li> <p>Faster than Django, Flask, Pyramid etc. and will get even faster as it is optimized further.</p> </li> </ul>"},{"location":"#why-another-python-web-framework","title":"Why Another Python Web Framework?","text":"<p>Because we needed something small enough to be learnt completely by new engineers in less than 10 minutes. Complete mastery with no grey spots.</p>"},{"location":"#okay-what-next","title":"Okay, What Next?","text":"<ul> <li> <p>Minute 1: Quickstart : Toe in the water</p> </li> <li> <p>Minute 2: Heaven Application</p> </li> <li> <p>Minute 3: Request to Heaven</p> </li> <li> <p>Minute 4: Responses from Heaven</p> </li> <li> <p>Minute 5: Context of Heaven</p> </li> <li> <p>Minute 6: Rendering HTML Templates &amp; Public Assets</p> </li> <li> <p>Minute 7: Drink some coffee</p> </li> <li> <p>Minute 8: Mounting Applications</p> </li> <li> <p>Minute 9: Authentication &amp; Data Validation Guidelines/Code Snippets</p> </li> <li> <p>Minute 10: Congratulate Yourself</p> </li> </ul>"},{"location":"api/","title":"Minute 1","text":"<p>We are assuming you have installed heaven via <code>pip install heaven</code>. If no, then go ahead and install it, otherwise let's dive in.</p>"},{"location":"api/#30000-foot-view","title":"30,000 Foot View...","text":"<pre><code>from heaven import Router\n\n\nrouter = Router()\n\n\nrouter.GET('/v1/customers', lambda r, w, c: pass)\n</code></pre>"},{"location":"congrats/","title":"Min. 10&colon; Congratulate Yourself","text":""},{"location":"congrats/#before-you-go-how-about-some-cheat-codes-","title":"Before you go... How about some cheat codes ;-)","text":"<p>We use heaven extensively to power numerous enterprise microservices and have collated some practices that might help you get there even faster.</p>"},{"location":"congrats/#decorators","title":"Decorators","text":"<p>In this example we use the <code>jsonschema</code> library to pass along validated data to our eventual handlers</p> <pre><code>from asyncio import iscoroutinefunction\nfrom functools import wraps\nfrom http import HTTPStatus\n\nfrom jsonschema import validate\nfrom jsonschema.exceptions import ValidationError\nfrom ujson import dumps, loads\n\n\ndef expects(schema: dict):\n    def wrapper(func):\n        @wraps(func)\n        async def delegate(r: Request, w: Response, c: Context):\n            try: json = loads(r.body)\n            except:\n                return w.status = HTTPStatus.UNPROCESSABLE_ENTITY\n\n            try: validate(schema, json, draft7_format_checker=True)\n            except ValidationError as exc:\n                w.body = dumps(exc)\n                return w.status = status.BAD_REQUEST\n\n            # little helper used in example handler below -&gt; c.age, c.email\n            for key in json: c.keep(key, json.get(key))\n\n            # so you can wrap async and non async handler variants\n            if iscoroutinefunction(func): return await func(r, w, c)\n            else: return func(r, w, c)\n        return delegate\n    return wrapper\n\n\n@expects({\n    'type': 'object',\n    'properties': {\n        'age': {'type': 'number', 'min': 18, 'max': 180},\n        'email': {'type': 'string', 'format': 'email'}\n    },\n    'required': ['age', 'email'],\n    'additionalProperties': false,\n})\nasync def create_customer_order(r: Request, w: Response, c: Context):\n    dbpool = r.app.peek('dbpool')\n    async with dbpool.acquire() as sqld:\n        try:\n            identifier = sqld.execute('... returning id')\n        except UniqueViolationsError:\n            return w.status = status.SERVICE_UNAVAILABLE\n\n    w.status = HTTPStatus.CREATED\n    w.body = dumps({\n        'identifier': identifier,\n        'age': c.age,\n        'email': c.email\n    })\n</code></pre> <p>This example demonstrates one of the ways Authentication might be implemented with the <code>pyjwt</code> library. <pre><code>from asyncpg import Pool\nfrom jwt import decode\n\n\ndef private(role: str):\n\"\"\"RBAC Authorization, heaven makes it easy to also use ABAC\"\"\"\n    def wrapper(func):\n        @wraps(func)\n        def delegate(r: Request, w: Response, c: Context):\n            dbpool: Pool = r.app.peek('dbpool')\n            with dbpool.acquire() as sqld:\n                try: roles = await sqld.fetchval(\"\"\"\n                    SELECT roles\n                    FROM privileges\n                    WHERE user = $1 AND action = $2\n                \"\"\", c.current_user, f'{r.method.lower()}s')\n                except:\n                    w.status = HTTPStatus.SERVICE_UNAVAILABLE\n                    w.body = dumps({'message': 'please try again later'})\n            if role in roles: return await func(r, w, c)\n\n            w.status = HTTPStatus.UNAUTHORIZED\n            w.body = dumps({'message': 'insufficient privileges'})\n        return delegate\n    return wrapper\n\n\ndef protected(func):\n\"\"\"Authentication\"\"\"\n    @wraps(func)\n    def delegate(r: Request, w: Response, c: Context):\n        token = r.headers.get('authorization')\n        secret_key = r.app.CONFIG('SECRET_KEY')\n\n        try: credentials = decode(token, secret_key, algorithm='HS256')\n        except: return w.status = status.UNAUTHORIZED\n        else: c.keep('current_user') = credentials.get('id')\n\n        return await func(r, w, c)\n    return delegate\n</code></pre></p>"},{"location":"context/","title":"Min. 4&colon; Context of Heaven","text":"<p><code>View Source Code:</code> <code>Open on GitHub</code></p>"},{"location":"context/#minute-4","title":"Minute 4","text":""},{"location":"context/#object-3-context","title":"Object #3. Context","text":"<p>All handlers receive this as the third argument i.e. <code>...(..., ..., c: Context)</code> to help with preserving state across     multiple handlers (i.e. from when a request is received to when a response is sent).</p> <ul> <li><code>c.keep(alias: str, value: any)</code> -&gt; Save something that can be retrieved via Python descriptor semantics. i.e. <code>c.alias</code> will return the kept value.</li> </ul> <pre><code>from functools import wraps\n\n\ndef example(func):\n    @wraps(func)\n    async def wrapper(req, res, ctx):\n        ctx.keep('user_id', 1986)\n        func(req, res, ctx)\n    return wrapper\n\n\n@example\ndef get_user(req, res, ctx):\n    assert ctx.user_id == 1986\n</code></pre> <p> </p> <p>Next: Application</p>"},{"location":"html/","title":"Minute 9: Guidelines and Code Snippets","text":"<p>Heaven is extremely unopinionated. Using python decorators; this section shows a few ways to combine standard python libraries like pydantic, PyJWT etc. with heaven.</p>"},{"location":"html/#authentication-example","title":"Authentication Example","text":"<pre><code>from functools import wraps\nfrom inspect import iscoroutinefunction\n\n# typing is amazing let's use it as much as we can\nfrom heaven import Context, Request, Response\n\n\ndef protect(func):\n    @wraps(func)\n    async def delegate(req: Request, res: Response, ctx: Context):\n        token = req.headers.get('authorization')\n\n        # use your preferred jwt or other validation lib/scheme here\n        if not token:\n            res.status = HTTPStatus.UNAUTHORIZED\n            res.body = 'Whatever body you want'\n            return\n\n        ctx.keep('user', {...})\n        if iscoroutinefunction(handler): await func(req, res, ctx)\n        else: func(req, res, ctx)\n    return delegate\n\n\n# use decorator to protect handler(s) of choice\n@protect\nasync def get_customer_info(req: Request, res: Response, ctx: Context):\n    res.body = {}\n</code></pre>"},{"location":"html/#data-validation-example","title":"Data Validation Example","text":"<pre><code>from heaven import ...  # necessary imports here\nfrom pydantic import BaseModel\n\n\nclass Guest(BaseModel):\n    email: EmailStr\n    password: str\n\n\ndef expects(model: BaseModel):\n    async def delegate(req: Request, res: Response, ctx: Context):\n        try:\n            data = loads(req.body)\n            guest = Guest(**data)\n        except:  # be more specific with exceptions in production code\n            res.status = HTTPStatus.BAD_REQUEST\n            return\n        ctx.keep('guest', Guest)\n    return delegate\n\n\n@expects(Guest)\nasync def do_login_with_email(req: Request, res: Response, ctx: Context):\n    guest: Guest = ctx.guest\n    print(guest.email)\n    print(guest.password)\n</code></pre>"},{"location":"mount/","title":"Heaven","text":"<p>Super small micro framework for building enterprise microservices and or web applications.</p>"},{"location":"mount/#why-another-python-web-framework","title":"Why Another Python Web Framework?","text":"<p>Because we needed something small enough to be learnt completely by new engineers in less than 5 minutes. Complete mastery with no gray spots.</p>"},{"location":"quickstart/","title":"Minute 1","text":"<p>We are assuming you have installed heaven via <code>pip install heaven</code>. If no, then go ahead and install it; If you have, then the clock is ticking so let's dive in.</p>"},{"location":"quickstart/#1-create-a-handler-function","title":"1. Create a handler function","text":"<p>In a file of your choosing: i.e. <code>controllers.py</code> or <code>src/controllers/customers.py</code> <pre><code>import json\nfrom http import HTTPStatus\n\nfrom heaven import Request, Response, Context\n\nasync def get_one_customer(req: Request, res: Response, ctx: Context):\n    id = req.params.get('id')\n    res.status = HTTPStatus.CREATED\n    res.body = json.dumps({\"message\": f\"heaven is easy for customer {id}\"})\n</code></pre></p> <p>As you can see above - your handler functions can also be async, and must accept 3 arguments that will be injected by heaven. We'll get to them in Minute 1, Minute 2 and Minute 3.</p>"},{"location":"quickstart/#2-connect-your-handler-to-the-heaven-application","title":"2. Connect your handler to the heaven application","text":"<pre><code>from heaven import Router\n\n# from your controller file above\nfrom controllers import get_one_customer\n\n# create the application\nrouter = Router()\n\n# connect it to a route\nrouter.GET('/v1/customers/:id', get_one_customer)\n</code></pre> <p>All HTTP methods i.e. <code>GET</code>, <code>POST</code> etc. are all supported</p>"},{"location":"quickstart/#3-run-with-gunicorn-or-uvicorn","title":"3. Run With Gunicorn or Uvicorn","text":"<pre><code># assuming your my_app.py is in a file called app.py\nuvicorn my_app:router  --reload --port 9000\n\n# or\n\ngunicorn -w 4 -k uvicorn.workers.UvicornWorker application:router\n</code></pre> <p>Next: Requests to Heaven</p>"},{"location":"request/","title":"Min. 2&colon; Request to Heaven","text":"<p><code>View Source Code:</code> <code>Open on GitHub</code></p>"},{"location":"request/#minute-2","title":"Minute 2","text":"<p>A promise is a promise. So it's time to tell you about heaven's objects. Don't fret - there are only 4 of them.</p>"},{"location":"request/#object-1-request","title":"Object #1: Request","text":"<p>All handlers will receive this as their first argument i.e. <code>...(req: Request, ..., ...)</code> - and all Request objects come with the following helper properties (bag of goodies).</p> <ul> <li> <p><code>req.app: Router</code> -&gt; An instance of the base heaven application</p> </li> <li> <p><code>req.body: bytes</code> -&gt; The body sent along with the request</p> </li> <li> <p><code>req.cookies: dict</code> -&gt; All the cookies sent with request [keys in lowercase]</p> </li> <li> <p><code>req.form: Form</code> -&gt; If content-type of <code>req</code> is <code>multipart/form-data</code>, this will return a form object - a light     wrapper on a dict.     <pre><code>def create_lead(req, res, ctx):\n    form = req.form\n    print(form.name)\n    print(form.password)\n</code></pre></p> </li> <li> <p><code>req.headers: dict</code> -&gt; All the headers sent with request [keys in lowercase] i..e <code>req.headers.get('content-type')</code></p> </li> <li> <p><code>req.method: str</code> -&gt; <code>GET</code>, <code>POST</code>, <code>DELETE</code>? What method type is the http request</p> </li> <li> <p><code>req.mounted: app</code> -&gt; The mounted router if this request handler is from a mounted router.     <pre><code>from router import Router, App\n\nrouter_1 = Router()\nrouter_1.GET('/', lambda req, res, ctx:...)\n\napp = App()\napp.mount(router) # all routes defined on router_1 will be mounted to app\n</code></pre>     Useful if you have different configurations on child routers and want to access them separately.</p> </li> <li> <p><code>req.params: dict</code> -&gt; Querystring parameters and url masks <code>/customers/:param1</code> parsed into a dictionary</p> </li> <li> <p><code>req.querystring: str</code> -&gt; The part after the <code>?</code> i.e. <code>example.com</code>?age=34 parsed in comma separated string form</p> </li> <li> <p><code>req.scheme: dict</code> -&gt; <code>http</code> or <code>https</code> i.e. what protocol is current request using.</p> </li> <li> <p><code>req.subdomain: str</code> -&gt; If request was made to a subdomain i.e. www<code>.example.org</code> or api<code>.example.org</code>     then this holds the subdomain value e.g. <code>www</code> and <code>api</code>.</p> </li> <li> <p><code>req.url: str</code> -&gt; The url that matched to this handler as sent by the client</p> </li> </ul> <p> </p> <p>Next: Response from Heaven</p>"},{"location":"response/","title":"Min. 3&colon; Response from Heaven","text":"<p><code>heaven.response.Response:</code> <code>Open on GitHub</code></p>"},{"location":"response/#minute-3","title":"Minute 3","text":""},{"location":"response/#object-2-response","title":"Object #2. Response","text":"<p>All handlers receive this as the second argument i.e. <code>...(..., res: Response, ...)</code> with the following <code>properties</code> &amp; <code>methods</code> to help with responding to http requests.</p> <ul> <li> <p><code>res.body: any = 'hello'</code> -&gt; Sets the body that will be sent back with the response object.</p> </li> <li> <p><code>res.defer: Callable = 'hello'</code> -&gt; Registers a function to be called after the response is sent to the client.         Method must accept a single parameter of <code>type: Router | Application</code> <pre><code>def send_sms_after_request(router: Router):\n        twilio = router.peek('twilio')\n        twilio.messages.create(to='+123456', from='+123456', body='Hi!')\n\n\nasync def create_order(req, res, ctx):\n        res.defer = send_sms_after_request\n        res.defer = lambda r: print('I will be called too...')\n        res.status = 202\n</code></pre></p> </li> <li> <p><code>res.headers: tuple[2] | list[2]</code> -&gt; How headers are set i.e.         <pre><code>res.headers = 'Set-Cookie', 'Token=12345; Max-Age=8700; Secure; HttpOnly'\n</code></pre></p> </li> <li> <p><code>res.status: int</code> -&gt; HTTP status code to be sent back with the response</p> </li> <li> <p><code>res.render(html: str, **context): Coroutine[str]</code> -&gt; Asynchronous function to help with         rendering html. See rendering html tutorial</p> </li> <li> <p><code>res.redirect(location: str)</code> -&gt; This does this for you behind the scenes.         <pre><code>res.status = HTTPStatus.TEMPORARY_REDIRECT\nres.headers = 'Location', '/location'\n</code></pre>         Browsers will redirect upon receipt of the header and http status above.</p> </li> <li> <p><code>res.abort(payload: any)</code> -&gt; If this is called then all <code>PRE</code> and <code>POST</code> hooks will be aborted</p> </li> </ul> <p>Here is a sample request handler function that shows almost all the functionality the <code>Response</code> object provides. <pre><code>async def hello(req, res: Response, ctx):\n    res.status = HTTPStatus.CREATED\n    res.headers = 'Content-Type', 'application/json'\n    res.body = dumps({'message': 'Why hello there...'})\n\n    # will overwrite res.body above\n    await res.render('index.html')  \n</code></pre></p> <p> </p> <p>Next: Context of Heaven</p>"},{"location":"router/","title":"Min. 5&colon; Application","text":"<p><code>View Source Code:</code> <code>Open on GitHub</code></p>"},{"location":"router/#minute-5","title":"Minute 5","text":""},{"location":"router/#object-4-router-application-app","title":"Object #4: Router | Application | App","text":"<p>A heaven <code>App</code>, <code>Application</code>, or <code>Router</code> can be imported by any of it's aliases and is what you deploy.</p> <pre><code>from heaven import App\nfrom heaven import Router\nfrom heaven import Application\n\nyes = App == Router == Application\n</code></pre>"},{"location":"router/#heaven-is-a-router","title":"Heaven is A Router","text":"<pre><code>router = Router()\n\n\nhandler = lambda req, res, ctx:...\n\n\n# GET, POST, PUT, PATCH, OPTIONS, DELETE, TRACE, all supported\nrouter.GET('/read', handler)\nrouter.POST('/write', handler)\n\n\n# register this handler for all http methods i.e. GET, POST, PUT, OPTIONS, etc...\nrouter.HTTP('/all', handler)\n\n\n# run this handler before all orders routes\nrouter.BEFORE('/orders/*', handler)\n\n# or even after\nrouter.AFTER('/orders/*', handler)\n</code></pre>"},{"location":"router/#additional-router-apis","title":"Additional Router APIs","text":"<ul> <li> <p><code>router.AFTER(url: str, handler: func, subdomain: str)</code> -&gt; This is called a hook - a function that is hooked to run after all matching routes.     <pre><code>message = 'I will run after all /v1/* routes'\nrouter.AFTER('/v1/*', lambda req, res, ctx: print(message))\n\n# will run after\nrouter.GET('/v1/customers', ...)\nrouter.POST('/v1/leads', ...)\n\n# but not after\nrouter.GET('/v2/customers')\n</code></pre></p> </li> <li> <p><code>router.BEFORE(url: str, handler: func, subdomain: str)</code> -&gt; Same as after hook above - but runs before all matching routes.</p> </li> <li> <p><code>router.GET(url: str, handler: func, subdomain: str)</code> -&gt; Registers your custom handlers/functions to be invoked when a request matches     the provided url. All other HTTP methods <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code> etc.      work in similar fashion. The <code>subdomain</code> optional argument limits the matching to a subdomain.</p> </li> <li> <p><code>router.HTTP(url: str, handler: func)</code> -&gt; Registers your custom handlers/functions to all HTTP methods i.e. GET, PUT, POST, PUT, PATCH instead of doing it individually.</p> </li> </ul>"},{"location":"router/#heaven-is-a-global-config-store","title":"Heaven is a Global Config &amp; Store","text":""},{"location":"router/#global-config","title":"Global Config","text":"<p><pre><code>router = Router({'secret_key': 'not so secret...'})\n</code></pre> This will be available in all handlers via the `req.app.CONFIG</p>"},{"location":"router/#additional-storestate-apis","title":"Additional Store/State APIs","text":"<ul> <li> <p><code>router.keep(key: str, value: any)</code> -&gt; Like. <code>c.keep()</code> but persisted across multiple request lifecycles.</p> </li> <li> <p><code>router.peek(key: str, value: any)</code> -&gt; Take a peek at your global dynamic application state without removing the kept value.</p> </li> <li> <p><code>router.unkeep(key: str, value: any)</code> -&gt; Remove and return the kept value from the global dynamic application state. </p> </li> </ul>"},{"location":"router/#customizing-your-heaven-application","title":"Customizing Your Heaven Application","text":"<pre><code># development\nfrom aiomysql import connect as Connection\nfrom redis import Redis\nfrom heaven import App  # also available as Router, Application\n\n\napp = App()\n\n\n# adding a database connection?\nasync def database_middleware(router: Router):\n    client = await Connection(host='localhost', port=3306, user='root', password='', db='mysql')\n    router.keep('db', client)\n\n\n# synchronous initialization also supported\ndef upredis(router: Router):\n    redis = Redis('localhost')\n    router.keep('redis', redis)\n\n\n# now use it in your handlers\nasync def create_order(req: Request, res: Response, ctx: Context):\n    db: Connection = req.app.peek('db')\n    await db.execute('''INSERT ...''')\n\n\napp.ON(STARTUP, updatabase)\napp.ON(SHUTDOWN, downdatabase)\napp.ONCE(upredis)\n\n\napp.POST('/orders', create_order)\n</code></pre>"},{"location":"router/#2-running-your-heaven-application-in-production","title":"2. Running your heaven application in production","text":"<pre><code># development\nuvicorn application:router --reload\n\n# production\ngunicorn -w 4 -k uvicorn.workers.UvicornWorker application:router\n</code></pre> <p>Replace the number after <code>-w</code> with the number of processors you desire to run your app with.</p> <p>Slow Down Tiger</p> <p>You might be asking - what about the applications port number etc? \ud83d\ude01</p>"},{"location":"snippets/","title":"Minute 9: Guidelines and Code Snippets","text":"<p>Heaven is extremely unopinionated. Using python decorators; this section shows a few ways to combine standard python libraries like pydantic, PyJWT etc. with heaven.</p>"},{"location":"snippets/#authentication-example","title":"Authentication Example","text":"<pre><code>from functools import wraps\nfrom inspect import iscoroutinefunction\n\n# typing is amazing let's use it as much as we can\nfrom heaven import Context, Request, Response\n\n\ndef protect(func):\n    @wraps(func)\n    async def delegate(req: Request, res: Response, ctx: Context):\n        token = req.headers.get('authorization')\n\n        # use your preferred jwt or other validation lib/scheme here\n        if not token:\n            res.status = HTTPStatus.UNAUTHORIZED\n            res.body = 'Whatever body you want'\n            return\n\n        ctx.keep('user', {...})\n        if iscoroutinefunction(handler): await func(req, res, ctx)\n        else: func(req, res, ctx)\n    return delegate\n\n\n# use decorator to protect handler(s) of choice\n@protect\nasync def get_customer_info(req: Request, res: Response, ctx: Context):\n    res.body = {}\n</code></pre>"},{"location":"snippets/#data-validation-example","title":"Data Validation Example","text":"<pre><code>from heaven import ...  # necessary imports here\nfrom pydantic import BaseModel\n\n\nclass Guest(BaseModel):\n    email: EmailStr\n    password: str\n\n\ndef expects(model: BaseModel):\n    async def delegate(req: Request, res: Response, ctx: Context):\n        try:\n            data = loads(req.body)\n            guest = Guest(**data)\n        except:  # be more specific with exceptions in production code\n            res.status = HTTPStatus.BAD_REQUEST\n            return\n        ctx.keep('guest', Guest)\n    return delegate\n\n\n@expects(Guest)\nasync def do_login_with_email(req: Request, res: Response, ctx: Context):\n    guest: Guest = ctx.guest\n    print(guest.email)\n    print(guest.password)\n</code></pre>"},{"location":"tutorials/router/","title":"Quickstart Tutorial","text":"<pre><code>$ uvicorn main:app --reload\n\n&lt;span style=\"color: green;\"&gt;INFO&lt;/span&gt;:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n&lt;span style=\"color: green;\"&gt;INFO&lt;/span&gt;:     Started reloader process [28720]\n&lt;span style=\"color: green;\"&gt;INFO&lt;/span&gt;:     Started server process [28722]\n&lt;span style=\"color: green;\"&gt;INFO&lt;/span&gt;:     Waiting for application startup.\n&lt;span style=\"color: green;\"&gt;INFO&lt;/span&gt;:     Application startup complete.\n---&gt; 100%\n</code></pre> <p>There are 4 ways to query your data using SuperSQL</p> <ul> <li>Identifier Interpolation</li> <li>Manually create a Table schema</li> <li>Automatically reflect tables from the database</li> <li>Use <code>dict</code> and <code>list</code> with variables</li> </ul> <p> </p>"},{"location":"tutorials/router/#identifier-interpolation","title":"Identifier Interpolation","text":"<pre><code>from os import environ\nfrom supersql import Query\n\nuser = environ.get('DB_USER')\npwd = environ.get('DB_PWD')\ndialect = environ.get('DB_ENGINE')\n\nquery = Query(vendor=dialect, user=user, password=pwd)\n\nresults = query.SELECT(\n    \"first_name\", \"last_name\", \"email\"\n).FROM(\n    \"employees\"\n).WHERE(\n    \"email = 'someone@example.com'\"  # WARNING: don't inject user provided values (SQL Injection Possible)\n).run()\n</code></pre> <p>Magic Literals Are Bad</p> <p>It is usually not advisable to repeat string or other constants in multiple places across your codebase. If you notice string or literal values repeating more than once consider turning them into constants.</p> <p>Identifiers ONLY</p> <p>It is advisable to limit use of strings to only identifiers e.g. <code>column names</code>, <code>table names</code>, <code>...</code> and operators <code>=</code>, <code>&lt;&gt;</code> etc.</p> <p> </p>"},{"location":"tutorials/router/#manually-create-table-schema","title":"Manually Create Table Schema","text":"<pre><code>from supersql import Table\n\n\nclass Employee(Table):...\n\n\nemp = Employee()\n\n\nresults = query.SELECT(\n    emp.first_name, emp.last_name, emp.email\n).FROM(\n    emp\n).WHERE(\n    emp.email == 'someone@example.com'\n).execute()  # `execute` fetches all data into memory\n</code></pre> <p>Run vs Execute</p> <p><code>execute()</code> fetches all data into memory. Do not use with unsafe queries to large tables e.g. <code>SELECT * FROM very_large_table</code>. Use <code>run()</code> as it fetches data in chunks and reconnects as necessary to fetch more data.</p> <p> </p>"},{"location":"tutorials/router/#auto-reflect-table-schema","title":"Auto-Reflect Table Schema","text":"<pre><code>...\n\n\ntables = query.database(\"dbname\").tables()\nemp = tables.get(\"employees\")\n\n\nresults = query.SELECT(\n    emp.first_name, emp.last_name, emp.email\n).FROM(\n    emp\n).WHERE(\n    emp.email == 'someone@example.com'\n).execute()\n</code></pre>"},{"location":"tutorials/router/#use-dict-lists-with-variables","title":"Use Dict &amp; Lists with Variables","text":"<pre><code>from supersql import Query\n\nquery = Query(...)  # connection parameters as required\n\ndef example(table, *args, **kwargs)\n    alt_results = query.SELECT(*args).FROM(table).WHERE(**kwargs).run()\n</code></pre>"},{"location":"tutorials/router/#okay-how-about-inserting-data","title":"Okay... How about inserting Data?","text":"<p>Adding or inserting data with SuperSQL is just as easy as querying data.</p> <p>However it is important for you to understand that SuperSQL is NOT AN ORM, and that means you can't use some magical <code>table.save()</code> method to insert data to the database.</p> <p>That's now how we roll... \u00a0 \u00a0 :smile:</p> <p>So how then do you insert data? Let's look at some code.</p> <pre><code># borrowing Query and Employee code from above\n...\n\ndef insert(**kwargs):\n    result = query.INSERT(\n        emp\n    ).VALUES(\n        **kwargs\n    ).execute()\n\n\ndef bulk_insert(*args):\n    result = query.INSERT(\n        emp.first_name,\n        emp.last_name,\n        emp.email\n    ).VALUES(\n        args\n    ).execute()\n\n\ndef insert_with_into(*args):\n    # Use of INTO(table) used here is 100% optional but arguably\n    # adds readability\n    results = Query.INSERT(\n        emp.first_name, emp.last_name, emp.email\n    ).INTO(\n        emp\n    ).VALUES(\n        [\"John\", \"Doe\", \"john.doe@example.net\"] if not args else args\n    ).execute()\n\nquery.INSERT().INTO().VALUES().WHERE_NOT_EXISTS()\n</code></pre>"}]}